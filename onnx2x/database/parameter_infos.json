{
  "Add": {
    "mindspore": {
      "mindspore.ops.add": {
        "input": {
          "def": "The first input is a number.Number or a bool or a tensor whose data type is number or bool_.",
          "isRequired": true,
          "type": "Union[tensor, number.Number, bool]"
        },
        "other": {
          "def": "The second input, when the first input is a tensor, the second input should be a number.Number or bool value, or a tensor whose data type is number or bool. When the first input is Scalar, the second input must be a tensor whose data type is number or bool.",
          "isRequired": true,
          "type": "Union[tensor, number.Number, bool]"
        }
      }
    },
    "onnx": {
      "axis": {
        "def": "If set, defines the broadcast dimensions",
        "type": "int"
      },
      "broadcast": {
        "def": "Pass 1 to enable broadcasting",
        "type": "int"
      }
    },
    "paddlepaddle": {
      "paddle.add": {
        "name": {
          "def": "For details, please refer to Name. Generally, no setting is required. Default: None.",
          "isRequired": false,
          "type": "string"
        },
        "x": {
          "def": "tensor or LoDtensor of any dimensions. Its dtype should be int32, int64, float32, float64.",
          "isRequired": true,
          "type": "tensor"
        },
        "y": {
          "def": "tensor or LoDtensor of any dimensions. Its dtype should be int32, int64, float32, float64.",
          "isRequired": true,
          "type": "tensor"
        }
      }
    },
    "pytorch": {
      "torch.add": {
        "alpha": {
          "def": "the multiplier for other.",
          "isRequired": false,
          "type": "number"
        },
        "input": {
          "def": "the input tensor.",
          "isRequired": true,
          "type": "tensor"
        },
        "other": {
          "def": "the tensor or number to add to input.",
          "isRequired": true,
          "type": "tensor"
        },
        "out": {
          "def": "the output tensor.",
          "isRequired": false,
          "type": "tensor"
        }
      }
    },
    "tensorflow": {
      "tf.keras.layers.Add": {}
    }
  },
  "AveragePool": {
    "mindspore": {
      "mindspore.nn.AvgPool1d": {
        "ceil_mode": {
          "def": "If True , use ceil to compute the output shape instead of floor. Default: False .",
          "isRequired": false,
          "type": "bool"
        },
        "count_include_pad": {
          "def": "If True , averaging calculation will include the zero-padding. Default: True .",
          "isRequired": false,
          "type": "bool"
        },
        "kernel_size": {
          "def": "The size of kernel window used to take the average value, Default: 1 .",
          "isRequired": false,
          "type": "int"
        },
        "pad_mode": {
          "def": "Specifies the padding mode with a padding value of 0. It can be set to: \"same\" , \"valid\" or \"pad\" . Default: \"valid\" .  \"same\": Pad the input at the begin and end so that the shape of input and output are the same when stride is set to 1. The amount of padding to is calculated by the operator internally. If the amount is even, it is uniformly distributed around the input, if it is odd, the excess padding is goes to the right side. If this mode is set, padding must be 0. \"valid\": No padding is applied to the input, and the output returns the maximum possible length. Extra pixels that could not complete a full stride will be discarded. If this mode is set, padding must be 0. \"pad\": Pad the input with a specified amount. In this mode, the amount of padding at the begin and end is determined by the padding parameter. If this mode is set, padding must be greater than or equal to 0.",
          "isRequired": false,
          "type": "str"
        },
        "padding": {
          "def": "Pooling padding value, only \"pad\" mode can be set to non-zero. Default: 0 . padding can only be an integer or a tuple/list containing a single integer, in which case padding times or padding[0] times are padded on both sides of the input.",
          "isRequired": false,
          "type": "Union(int, tuple[int], list[int]"
        },
        "stride": {
          "def": "The distance of kernel moving, an int number that represents the width of movement is strides, Default: 1 .",
          "isRequired": false,
          "type": "int"
        }
      },
      "mindspore.nn.AvgPool2d": {
        "ceil_mode": {
          "def": "If True , use ceil to compute the output shape instead of floor. Default: False .",
          "isRequired": false,
          "type": "bool"
        },
        "count_include_pad": {
          "def": "If True , averaging calculation will include the zero-padding. Default: True .",
          "isRequired": false,
          "type": "bool"
        },
        "data_format": {
          "def": "The optional value for data format, is 'NHWC' or 'NCHW' . Default: 'NCHW' .",
          "isRequired": false,
          "type": "str"
        },
        "divisor_override": {
          "def": "If it is specified as a non-zero parameter, this parameter will be used as the divisor in the average calculation. Otherwise, kernel_size will be used as the divisor. Default: None .",
          "isRequired": false,
          "type": "int"
        },
        "kernel_size": {
          "def": "The size of kernel used to take the average value. The data type of kernel_size must be int or a single element tuple and the value represents the height and width, or a tuple of two int numbers that represent height and width respectively. Default: 1 .",
          "isRequired": false,
          "type": "Union[int, tuple[int]]"
        },
        "pad_mode": {
          "def": "Specifies the padding mode with a padding value of 0. It can be set to: \"same\" , \"valid\" or \"pad\" . Default: \"valid\" .  \"same\": Pad the input around its edges so that the shape of input and output are the same when stride is set to 1. The amount of padding to is calculated by the operator internally, If the amount is even, it is uniformly distributed around the input, if it is odd, the excess amount goes to the right/bottom side. If this mode is set, padding must be 0. \"valid\": No padding is applied to the input, and the output returns the maximum possible height and width. Extra pixels that could not complete a full stride will be discarded. If this mode is set, padding must be 0. \"pad\": Pad the input with a specified amount. In this mode, the amount of padding in the height and width directions is determined by the padding parameter. If this mode is set, padding must be greater than or equal to 0.",
          "isRequired": false,
          "type": "str"
        },
        "padding": {
          "def": "Pooling padding value, only \"pad\" mode can be set to non-zero. Default: 0 . padding can only be an integer or a tuple/list containing one or two integers. If padding is an integer or a tuple/list containing one integer, it will be padded padding times in the four directions of the input. If padding is a tuple/list containing two integers, it will be padded padding[0] times in the up-down direction of the input and padding[1] times in the left-right direction of the input.",
          "isRequired": false,
          "type": "Union(int, tuple[int], list[int]"
        },
        "stride": {
          "def": "The distance of kernel moving, an int number or a single element tuple that represents the height and width of movement are both strides, or a tuple of two int numbers that represent height and width of movement respectively. Default: 1 .",
          "isRequired": false,
          "type": "Union[int, tuple[int]]"
        }
      },
      "mindspore.nn.AvgPool3d": {
        "ceil_mode": {
          "def": "If True , use ceil to compute the output shape instead of floor. Default: False .",
          "isRequired": false,
          "type": "bool"
        },
        "count_include_pad": {
          "def": "If True , averaging calculation will include the zero-padding. Default: True .",
          "isRequired": false,
          "type": "bool"
        },
        "divisor_override": {
          "def": "If it is specified as a non-zero parameter, this parameter will be used as the divisor in the average calculation. Otherwise, kernel_size will be used as the divisor. Default: None .",
          "isRequired": false,
          "type": "int"
        },
        "kernel_size": {
          "def": "The size of kernel used to take the average value, can be an int number or a single element tuple that represents depth, height and width, or a tuple of three positive integers that represent depth, height and width respectively. Default: 1 .",
          "isRequired": false,
          "type": "Union[int, tuple[int]]"
        },
        "pad_mode": {
          "def": "Specifies the padding mode with a padding value of 0. It can be set to: \"same\" , \"valid\" or \"pad\" . Default: \"valid\" .  \"same\": Pad the input around its depth/height/width dimension so that the shape of input and output are the same when stride is set to 1. The amount of padding to is calculated by the operator internally.  If the amount is even, it isuniformly distributed around the input, if it is odd, the excess amount goes to the front/right/bottom side. If this mode is set, padding must be 0. \"valid\": No padding is applied to the input, and the output returns the maximum possible depth, height and width. Extra pixels that could not complete a full stride will be discarded. If this mode is set, padding must be 0. \"pad\": Pad the input with a specified amount. In this mode, the amount of padding in the depth, height and width dimension is determined by the padding parameter. If this mode is set, padding must be greater than or equal to 0.",
          "isRequired": false,
          "type": "str"
        },
        "padding": {
          "def": "Pooling padding value, only \"pad\" mode can be set to non-zero. Default: 0 . Only the following paddings are supported:  padding is an integer or a tuple/list containing one integer, it will be padded in six directions of front, back, top, bottom, left and right of the input. padding is a tuple/list containing three integers, it will be padded in front and back of the input padding[0] times, up and down padding[1] times, and left and right of the input padding[2] times.",
          "isRequired": false,
          "type": "Union(int, tuple[int], list[int]"
        },
        "stride": {
          "def": "The distance of kernel moving, can be a positive int or a single element tuple that represents the depth, height and width of movement, or a tuple of three positive integers that represents depth, height and width of movement respectively. If the value is None, the default value kernel_size is used. Default: 1 .",
          "isRequired": false,
          "type": "Union[int, tuple[int]]"
        }
      }
    },
    "onnx": {
      "auto_pad": {
        "def": "auto_pad must be either NOTSET, SAME_UPPER, SAME_LOWER or VALID.Where default value is NOTSET, which means explicit padding is used.SAME_UPPER or SAME_LOWER mean pad the input so that output_shape[i] = ceil(input_shape[i] / strides[i]) for each axis i",
        "type": "string"
      },
      "ceil_mode": {
        "def": "Whether to use ceil or floor (default) to compute the output shape.",
        "type": "int"
      },
      "count_include_pad": {
        "def": "Whether include pad pixels when calculating values for the edges.Default is 0, doesn\u2019t count include pad.",
        "type": "int"
      },
      "dilations": {
        "def": "Dilation value along each spatial axis of filter",
        "type": "ints"
      },
      "kernel_shape": {
        "def": "The size of the kernel along each axis.",
        "type": "ints"
      },
      "pads": {
        "def": "Padding for the beginning and ending along each spatial axis, it cantake any value greater than or equal to 0",
        "type": "ints"
      },
      "strides": {
        "def": "Stride along each spatial axis",
        "type": "ints"
      }
    },
    "paddlepaddle": {
      "paddle.nn.AvgPool1D": {
        "ceil_mode": {
          "def": "${ceil_mode_comment}Whether to use the ceil function to calculate output height and width. If it is set to False, the floor function will be used. The default value is False.",
          "isRequired": false,
          "type": "bool"
        },
        "exclusive": {
          "def": "Whether to exclude padding points in average pooling mode, default is True.",
          "isRequired": false,
          "type": "bool"
        },
        "kernel_size": {
          "def": "The pool kernel size. If pool kernel size is a tuple or list, it must contain an integer.",
          "isRequired": true,
          "type": "int|list|tuple"
        },
        "name": {
          "def": "For eed to detailed information, please refer to Name. Usually name is no nset and None by default.",
          "isRequired": false,
          "type": "str"
        },
        "padding": {
          "def": "The padding size. Padding could be in one of the following forms. 1. A string in [\u2018valid\u2019, \u2018same\u2019]. 2. An int, which means the feature map is zero padded by size of padding on every sides. 3. A list[int] or tuple(int) whose length is 1, which means the feature map is zero padded by the size of padding[0] on every sides. 4. A list[int] or tuple(int) whose length is 2. It has the form [pad_before, pad_after]. 5. A list or tuple of pairs of integers. It has the form [[pad_before, pad_after], [pad_before, pad_after], \u2026]. Note that, the batch dimension and channel dimension should be [0,0] or (0,0). The default value is 0.",
          "isRequired": false,
          "type": "str|int|list|tuple"
        },
        "stride": {
          "def": "The pool stride size. If pool stride size is a tuple or list, it must contain an integer. Default None, then stride will be equal to the kernel_size.",
          "isRequired": false,
          "type": "int|list|tuple"
        }
      },
      "paddle.nn.AvgPool2D": {
        "ceil_mode": {
          "def": "When True, will use ceil instead of floor to compute the output shape.",
          "isRequired": false,
          "type": "bool"
        },
        "data_format": {
          "def": "The data format of the input and output data. An optional string from: \u201cNCHW\u201d, \u201cNDHW\u201d. The default is \u201cNCHW\u201d. When it is \u201cNCHW\u201d, the data is stored in the order of: [batch_size, input_channels, input_height, input_width].",
          "isRequired": false,
          "type": "str"
        },
        "divisor_override": {
          "def": "If specified, it will be used as divisor, otherwise kernel_size will be used. Default None.",
          "isRequired": false,
          "type": "float"
        },
        "exclusive": {
          "def": "Whether to exclude padding points in average pooling mode, default is true.",
          "isRequired": false,
          "type": "bool"
        },
        "kernel_size": {
          "def": "The pool kernel size. If pool kernel size is a tuple or list, it must contain two integers, (pool_size_Height, pool_size_Width). Otherwise, the pool kernel size will be a square of an int.",
          "isRequired": true,
          "type": "int|list|tuple"
        },
        "name": {
          "def": "For detailed information, please refer to Name. Usually name is no need to set and None by default.",
          "isRequired": false,
          "type": "str"
        },
        "padding": {
          "def": "The padding size. Padding could be in one of the following forms. 1. A string in [\u2018valid\u2019, \u2018same\u2019]. 2. An int, which means the feature map is zero padded by size of padding on every sides. 3. A list[int] or tuple(int) whose length is 2, [pad_height, pad_weight] whose value means the padding size of each dimension. 4. A list[int] or tuple(int) whose length is 4. [pad_height_top, pad_height_bottom, pad_width_left, pad_width_right] whose value means the padding size of each side. 5. A list or tuple of pairs of integers. It has the form [[pad_before, pad_after], [pad_before, pad_after], \u2026]. Note that, the batch dimension and channel dimension should be [0,0] or (0,0). The default value is 0.",
          "isRequired": false,
          "type": "str|int|list|tuple"
        },
        "stride": {
          "def": "The pool stride size. If pool stride size is a tuple or list, it must contain two integers, (pool_stride_Height, pool_stride_Width). Otherwise, the pool stride size will be a square of an int. Default None, then stride will be equal to the kernel_size.",
          "isRequired": false,
          "type": "int|list|tuple"
        }
      },
      "paddle.nn.AvgPool3D": {
        "ceil_mode": {
          "def": "${ceil_mode_comment}",
          "isRequired": false,
          "type": "bool"
        },
        "data_format": {
          "def": "The data format of the input and output data. An optional string from: \u201cNCDHW\u201d, \u201cNDHWC\u201d. The default is \u201cNCDHW\u201d. When it is \u201cNCDHW\u201d, the data is stored in the order of: [batch_size, input_channels, input_depth, input_height, input_width].",
          "isRequired": false,
          "type": "str"
        },
        "divisor_override": {
          "def": "if specified, it will be used as divisor, otherwise kernel_size will be used. Default None.",
          "isRequired": false,
          "type": "int|float"
        },
        "exclusive": {
          "def": "Whether to exclude padding points in average pooling mode, default is True.",
          "isRequired": false,
          "type": "bool"
        },
        "kernel_size": {
          "def": "The pool kernel size. If pool kernel size is a tuple or list, it must contain three integers, (kernel_size_Depth, kernel_size_Height, kernel_size_Width). Otherwise, the pool kernel size will be the cube of an int.",
          "isRequired": true,
          "type": "int|list|tuple"
        },
        "name": {
          "def": "For detailed information, please refer to Name. Usually name is no need to set and None by default.",
          "isRequired": false,
          "type": "str"
        },
        "padding": {
          "def": "The padding size. Padding could be in one of the following forms. 1. A string in [\u2018valid\u2019, \u2018same\u2019]. 2. An int, which means the feature map is zero padded by size of padding on every sides. 3. A list[int] or tuple(int) whose length is 3, [pad_depth, pad_height, pad_weight] whose value means the padding size of each dimension. 4. A list[int] or tuple(int) whose length is 6. [pad_depth_front, pad_depth_back, pad_height_top, pad_height_bottom, pad_width_left, pad_width_right] whose value means the padding size of each side. 5. A list or tuple of pairs of integers. It has the form [[pad_before, pad_after], [pad_before, pad_after], \u2026]. Note that, the batch dimension and channel dimension should be [0,0] or (0,0). The default value is 0.",
          "isRequired": false,
          "type": "str|int|list|tuple"
        },
        "stride": {
          "def": "The pool stride size. If pool stride size is a tuple or list, it must contain three integers, [stride_Depth, stride_Height, stride_Width). Otherwise, the pool stride size will be a cube of an int. Default None, then stride will be equal to the kernel_size.",
          "isRequired": false,
          "type": "int|list|tuple"
        }
      }
    },
    "pytorch": {
      "torch.nn.AvgPool1d": {
        "ceil_mode": {
          "def": "when True, will use ceil instead of floor to compute the output shape",
          "isRequired": false,
          "type": "bool"
        },
        "count_include_pad": {
          "def": "when True, will include the zero-padding in the averaging calculation",
          "isRequired": false,
          "type": "bool"
        },
        "kernel_size": {
          "def": "the size of the window",
          "isRequired": true,
          "type": "ints"
        },
        "padding": {
          "def": "implicit zero padding to be added on both sides",
          "isRequired": false,
          "type": "ints"
        },
        "stride": {
          "def": "the stride of the window",
          "isRequired": false,
          "type": "ints"
        }
      },
      "torch.nn.AvgPool2d": {
        "ceil_mode": {
          "def": "when True, will use ceil instead of floor to compute the output shape",
          "isRequired": false,
          "type": "bool"
        },
        "count_include_pad": {
          "def": "when True, will include the zero-padding in the averaging calculation",
          "isRequired": false,
          "type": "bool"
        },
        "divisor_override": {
          "def": "if specified, it will be used as divisor, otherwise size of the pooling region will be used.",
          "isRequired": false,
          "type": "optionalint"
        },
        "kernel_size": {
          "def": "the size of the window",
          "isRequired": true,
          "type": "unionint tupleint int"
        },
        "padding": {
          "def": "implicit zero padding to be added on both sides",
          "isRequired": false,
          "type": "unionint tupleint int"
        },
        "stride": {
          "def": "the stride of the window",
          "isRequired": false,
          "type": "unionint tupleint int"
        }
      },
      "torch.nn.AvgPool3d": {
        "ceil_mode": {
          "def": "when True, will use ceil instead of floor to compute the output shape",
          "isRequired": false,
          "type": "bool"
        },
        "count_include_pad": {
          "def": "when True, will include the zero-padding in the averaging calculation",
          "isRequired": false,
          "type": "bool"
        },
        "divisor_override": {
          "def": "if specified, it will be used as divisor, otherwise kernel_size will be used",
          "isRequired": false,
          "type": "optionalint"
        },
        "kernel_size": {
          "def": "the size of the window",
          "isRequired": true,
          "type": "unionint tupleint int int"
        },
        "padding": {
          "def": "implicit zero padding to be added on all three sides",
          "isRequired": false,
          "type": "unionint tupleint int int"
        },
        "stride": {
          "def": "the stride of the window",
          "isRequired": false,
          "type": "unionint tupleint int int"
        }
      }
    },
    "tensorflow": {
      "tf.keras.layers.AveragePooling1D": {
        "data_format": {
          "def": "A string, one of channels_last (default) or channels_first. The ordering of the dimensions in the inputs. channels_last corresponds to inputs with shape (batch, steps, features) while channels_first corresponds to inputs with shape (batch, features, steps).",
          "isRequired": false,
          "type": "string"
        },
        "padding": {
          "def": "One of \"valid\" or \"same\" (case-insensitive). \"valid\" means no padding. \"same\" results in padding evenly to the left/right or up/down of the input such that output has the same height/width dimension as the input.",
          "isRequired": false,
          "type": "string"
        },
        "pool_size": {
          "def": "Integer, size of the average pooling windows.",
          "isRequired": false,
          "type": "int"
        },
        "strides": {
          "def": "Integer, or None. Factor by which to downscale. E.g. 2 will halve the input. If None, it will default to pool_size.",
          "isRequired": false,
          "type": "int"
        }
      },
      "tf.keras.layers.AveragePooling2D": {
        "data_format": {
          "def": "A string, one of channels_last (default) or channels_first. The ordering of the dimensions in the inputs. channels_last corresponds to inputs with shape (batch, height, width, channels) while channels_first corresponds to inputs with shape (batch, channels, height, width). When unspecified, uses image_data_format value found in your Keras config file at ~/.keras/keras.json (if exists) else 'channels_last'. Defaults to 'channels_last'.",
          "isRequired": false,
          "type": "string"
        },
        "padding": {
          "def": "One of \"valid\" or \"same\" (case-insensitive). \"valid\" means no padding. \"same\" results in padding evenly to the left/right or up/down of the input such that output has the same height/width dimension as the input.",
          "isRequired": false,
          "type": "string"
        },
        "pool_size": {
          "def": "integer or tuple of 2 integers, factors by which to downscale (vertical, horizontal). (2, 2) will halve the input in both spatial dimension. If only one integer is specified, the same window length will be used for both dimensions.",
          "isRequired": false,
          "type": "int"
        },
        "strides": {
          "def": "Integer, tuple of 2 integers, or None. Strides values. If None, it will default to pool_size.",
          "isRequired": false,
          "type": "int"
        }
      },
      "tf.keras.layers.AveragePooling3D": {
        "data_format": {
          "def": "A string, one of channels_last (default) or channels_first. The ordering of the dimensions in the inputs. channels_last corresponds to inputs with shape (batch, spatial_dim1, spatial_dim2, spatial_dim3, channels) while channels_first corresponds to inputs with shape (batch, channels, spatial_dim1, spatial_dim2, spatial_dim3). When unspecified, uses image_data_format value found in your Keras config file at ~/.keras/keras.json (if exists) else 'channels_last'. Defaults to 'channels_last'.",
          "isRequired": false,
          "type": "string"
        },
        "padding": {
          "def": "One of \"valid\" or \"same\" (case-insensitive). \"valid\" means no padding. \"same\" results in padding evenly to the left/right or up/down of the input such that output has the same height/width dimension as the input.",
          "isRequired": false,
          "type": "string"
        },
        "pool_size": {
          "def": "tuple of 3 integers, factors by which to downscale (dim1, dim2, dim3). (2, 2, 2) will halve the size of the 3D input in each dimension.",
          "isRequired": false,
          "type": "int"
        },
        "strides": {
          "def": "tuple of 3 integers, or None. Strides values.",
          "isRequired": false,
          "type": "int"
        }
      }
    }
  },
  "BatchNormalization": {
    "mindspore": {
      "mindspore.nn.BatchNorm1d": {
        "affine": {
          "def": "A bool value. When set to True , \\(\\gamma\\) and \\(\\beta\\) can be learned. Default: True .",
          "isRequired": false,
          "type": "bool"
        },
        "beta_init": {
          "def": "Initializer for the \\(\\beta\\) weight. The values of str refer to the function mindspore.common.initializer including 'zeros' , 'ones', etc. Default: 'zeros' .",
          "isRequired": false,
          "type": "Union[tensor, str, Initializer, numbers.Number]"
        },
        "data_format": {
          "def": "The optional value for data format, is 'NHWC' or 'NCHW' . Default: 'NCHW' .",
          "isRequired": false,
          "type": "str"
        },
        "dtype": {
          "def": "Dtype of Parameters. Default: mstype.float32 .",
          "isRequired": false,
          "type": "mindspore.dtype"
        },
        "eps": {
          "def": "\\(\\epsilon\\) added to the denominator for numerical stability. Default: 1e-5 .",
          "isRequired": false,
          "type": "float"
        },
        "gamma_init": {
          "def": "Initializer for the \\(\\gamma\\) weight. The values of str refer to the function mindspore.common.initializer including 'zeros' , 'ones' , etc. Default: 'ones' .",
          "isRequired": false,
          "type": "Union[tensor, str, Initializer, numbers.Number]"
        },
        "momentum": {
          "def": "A floating hyperparameter of the momentum for the running_mean and running_var computation. Default: 0.9 .",
          "isRequired": false,
          "type": "float"
        },
        "moving_mean_init": {
          "def": "Initializer for the moving mean. The values of str refer to the function mindspore.common.initializer including 'zeros' , 'ones' , etc. Default: 'zeros' .",
          "isRequired": false,
          "type": "Union[tensor, str, Initializer, numbers.Number]"
        },
        "moving_var_init": {
          "def": "Initializer for the moving variance. The values of str refer to the function mindspore.common.initializer including 'zeros' , 'ones' , etc. Default: 'ones' .",
          "isRequired": false,
          "type": "Union[tensor, str, Initializer, numbers.Number]"
        },
        "num_features": {
          "def": "number of features or channels C of the input x .",
          "isRequired": true,
          "type": "int"
        },
        "use_batch_statistics": {
          "def": "If true , use the mean value and variance value of current batch data. If false , use the mean value and variance value of specified value. If None , the training process will use the mean and variance of current batch data and track the running mean and variance, the evaluation process will use the running mean and variance. Default: None .",
          "isRequired": false,
          "type": "bool"
        }
      },
      "mindspore.nn.BatchNorm2d": {
        "affine": {
          "def": "A bool value. When set to True , \\(\\gamma\\) and \\(\\beta\\) can be learned. Default: True .",
          "isRequired": false,
          "type": "bool"
        },
        "beta_init": {
          "def": "Initializer for the \\(\\beta\\) weight. The values of str refer to the function mindspore.common.initializer including 'zeros' , 'ones' , etc. Default: 'zeros' .",
          "isRequired": false,
          "type": "Union[tensor, str, Initializer, numbers.Number]"
        },
        "data_format": {
          "def": "The optional value for data format, is 'NHWC' or 'NCHW' . Default: 'NCHW' .",
          "isRequired": false,
          "type": "str"
        },
        "dtype": {
          "def": "Dtype of Parameters. Default: mstype.float32 .",
          "isRequired": false,
          "type": "mindspore.dtype"
        },
        "eps": {
          "def": "\\(\\epsilon\\) added to the denominator for numerical stability. Default: 1e-5 .",
          "isRequired": false,
          "type": "float"
        },
        "gamma_init": {
          "def": "Initializer for the \\(\\gamma\\) weight. The values of str refer to the function mindspore.common.initializer including 'zeros' , 'ones' , etc. Default: 'ones' .",
          "isRequired": false,
          "type": "Union[tensor, str, Initializer, numbers.Number]"
        },
        "momentum": {
          "def": "A floating hyperparameter of the momentum for the running_mean and running_var computation. Default: 0.9 .",
          "isRequired": false,
          "type": "float"
        },
        "moving_mean_init": {
          "def": "Initializer for the moving mean. The values of str refer to the function mindspore.common.initializer including 'zeros' , 'ones' , etc. Default: 'zeros' .",
          "isRequired": false,
          "type": "Union[tensor, str, Initializer, numbers.Number]"
        },
        "moving_var_init": {
          "def": "Initializer for the moving variance. The values of str refer to the function mindspore.common.initializer including 'zeros' , 'ones' , etc. Default: 'ones' .",
          "isRequired": false,
          "type": "Union[tensor, str, Initializer, numbers.Number]"
        },
        "num_features": {
          "def": "The number of channels of the input tensor. Expected input size is \\((N, C, H, W)\\), C represents the number of channels.",
          "isRequired": true,
          "type": "int"
        },
        "use_batch_statistics": {
          "def": "Default: None .  If true , use the mean value and variance value of current batch data and track running mean and running variance. If false , use the mean value and variance value of specified value, and not track statistical value. If None , the use_batch_statistics is automatically set to true or false according to the training and evaluation mode. During training, the parameter is set to true, and during evaluation, the parameter is set to false.",
          "isRequired": false,
          "type": "bool"
        }
      },
      "mindspore.nn.BatchNorm3d": {
        "affine": {
          "def": "A bool value. When set to True , gamma and beta can be learned. Default: True .",
          "isRequired": false,
          "type": "bool"
        },
        "beta_init": {
          "def": "Initializer for the beta weight. The values of str refer to the function mindspore.common.initializer including 'zeros' , 'ones' , etc. Default: 'zeros' .",
          "isRequired": false,
          "type": "Union[tensor, str, Initializer, numbers.Number]"
        },
        "dtype": {
          "def": "Dtype of Parameters. Default: mstype.float32 .",
          "isRequired": false,
          "type": "mindspore.dtype"
        },
        "eps": {
          "def": "A value added to the denominator for numerical stability. Default: 1e-5 .",
          "isRequired": false,
          "type": "float"
        },
        "gamma_init": {
          "def": "Initializer for the gamma weight. The values of str refer to the function mindspore.common.initializer including 'zeros' , 'ones' , etc. Default: 'ones' .",
          "isRequired": false,
          "type": "Union[tensor, str, Initializer, numbers.Number]"
        },
        "momentum": {
          "def": "A floating hyperparameter of the momentum for the running_mean and running_var computation. Default: 0.9 .",
          "isRequired": false,
          "type": "float"
        },
        "moving_mean_init": {
          "def": "Initializer for the moving mean. The values of str refer to the function mindspore.common.initializer including 'zeros' , 'ones' , etc. Default: 'zeros' .",
          "isRequired": false,
          "type": "Union[tensor, str, Initializer, numbers.Number]"
        },
        "moving_var_init": {
          "def": "Initializer for the moving variance. The values of str refer to the function mindspore.common.initializer including 'zeros' , 'ones' , etc. Default: 'ones' .",
          "isRequired": false,
          "type": "Union[tensor, str, Initializer, numbers.Number]"
        },
        "num_features": {
          "def": "C from an expected input of size \\((N, C, D, H, W)\\) .",
          "isRequired": true,
          "type": "int"
        },
        "use_batch_statistics": {
          "def": "If true, use the mean value and variance value of current batch data. If false, use the mean value and variance value of specified value. If None , the training process will use the mean and variance of current batch data and track the running mean and variance, the evaluation process will use the running mean and variance. Default: None .",
          "isRequired": false,
          "type": "bool"
        }
      }
    },
    "onnx": {
      "epsilon": {
        "def": "The epsilon value to use to avoid division by zero.",
        "type": "float"
      },
      "momentum": {
        "def": "Factor used in computing the running mean and variance.e.g.,running_mean = running_mean * momentum + mean * (1 - momentum).",
        "type": "float"
      },
      "training_mode": {
        "def": "If set to true, it indicates BatchNormalization is being used fortraining, and outputs 1, 2, 3, and 4 would be populated.",
        "type": "int"
      }
    },
    "paddlepaddle": {
      "paddle.nn.BatchNorm1D": {
        "bias_attr": {
          "def": "The parameter attribute for the bias of batch_norm. If it is set to None or one attribute of ParamAttr, batch_norm will create ParamAttr as bias_attr. If it is set to False, the weight is not learnable. If the Initializer of the bias_attr is not set, the bias is initialized zero. Default: None.",
          "isRequired": false,
          "type": "ParamAttr|bool"
        },
        "data_format": {
          "def": "Specify the input data format, may be \u201cNC\u201d, \u201cNCL\u201d or \u201cNLC\u201d, where N is batch size, C is the number of the feature map, L is the length of the feature map. Default \u201cNCL\u201d.",
          "isRequired": false,
          "type": "str"
        },
        "epsilon": {
          "def": "The small value added to the variance to prevent division by zero. Default: 1e-5.",
          "isRequired": false,
          "type": "float"
        },
        "momentum": {
          "def": "The value used for the moving_mean and moving_var computation. Default: 0.9.",
          "isRequired": false,
          "type": "float"
        },
        "name": {
          "def": "Name for the BatchNorm, default is None. For more information, please refer to Name..",
          "isRequired": false,
          "type": "str"
        },
        "num_features": {
          "def": "Indicate the number of channels of the input tensor.",
          "isRequired": true,
          "type": "int"
        },
        "use_global_stats": {
          "def": "Whether to use global mean and variance. If set to False, use the statistics of one mini-batch, if set to True, use the global statistics, if set to None, use global statistics in the test phase and use the statistics of one mini-batch in the training phase. Default: None.",
          "isRequired": false,
          "type": "bool|None"
        },
        "weight_attr": {
          "def": "The parameter attribute for Parameter scale of batch_norm. If it is set to None or one attribute of ParamAttr, batch_norm will create ParamAttr as weight_attr. If it is set to False, the weight is not learnable. If the Initializer of the weight_attr is not set, the parameter is initialized with ones. Default: None.",
          "isRequired": false,
          "type": "ParamAttr|bool"
        }
      },
      "paddle.nn.BatchNorm2D": {
        "bias_attr": {
          "def": "The parameter attribute for the bias of batch_norm. If it is set to None or one attribute of ParamAttr, batch_norm will create ParamAttr as bias_attr. If it is set to False, the weight is not learnable. If the Initializer of the bias_attr is not set, the bias is initialized zero. Default: None.",
          "isRequired": false,
          "type": "ParamAttr|bool"
        },
        "data_format": {
          "def": "Specify the input data format, the data format can be \u201cNCHW\u201d or \u201cNHWC\u201d, where N is batch size, C is the number of the feature map, H is the height of the feature map, W is the width of the feature map. Default: NCHW.",
          "isRequired": false,
          "type": "str"
        },
        "epsilon": {
          "def": "The small value added to the variance to prevent division by zero. Default: 1e-5.",
          "isRequired": false,
          "type": "float"
        },
        "momentum": {
          "def": "The value used for the moving_mean and moving_var computation. Default: 0.9.",
          "isRequired": false,
          "type": "float"
        },
        "name": {
          "def": "Name for the BatchNorm, default is None. For more information, please refer to Name..",
          "isRequired": false,
          "type": "str"
        },
        "num_features": {
          "def": "Indicate the number of channels of the input tensor.",
          "isRequired": true,
          "type": "int"
        },
        "use_global_stats": {
          "def": "Whether to use global mean and variance. If set to False, use the statistics of one mini-batch, if set to True, use the global statistics, if set to None, use global statistics in the test phase and use the statistics of one mini-batch in the training phase. Default: None.",
          "isRequired": false,
          "type": "bool|None"
        },
        "weight_attr": {
          "def": "The parameter attribute for Parameter scale of batch_norm. If it is set to None or one attribute of ParamAttr, batch_norm will create ParamAttr as weight_attr. If it is set to False, the weight is not learnable. If the Initializer of the weight_attr is not set, the parameter is initialized with ones. Default: None.",
          "isRequired": false,
          "type": "ParamAttr|bool"
        }
      },
      "paddle.nn.BatchNorm3D": {
        "bias_attr": {
          "def": "The parameter attribute for the bias of batch_norm. If it is set to None or one attribute of ParamAttr, batch_norm will create ParamAttr as bias_attr. If it is set to False, the weight is not learnable. If the Initializer of the bias_attr is not set, the bias is initialized zero. Default: None.",
          "isRequired": false,
          "type": "ParamAttr|bool"
        },
        "data_format": {
          "def": "Specify the input data format, the data format can be \u201cNCDHW\u201d or \u201cNDHWC\u201d, where N is batch size, C is the number of the feature map, D is the depth of the feature, H is the height of the feature map, W is the width of the feature map. Default: NCDHW.",
          "isRequired": false,
          "type": "str"
        },
        "epsilon": {
          "def": "The small value added to the variance to prevent division by zero. Default: 1e-5.",
          "isRequired": false,
          "type": "float"
        },
        "momentum": {
          "def": "The value used for the moving_mean and moving_var computation. Default: 0.9.",
          "isRequired": false,
          "type": "float"
        },
        "name": {
          "def": "Name for the BatchNorm, default is None. For more information, please refer to Name..",
          "isRequired": false,
          "type": "str"
        },
        "num_features": {
          "def": "Indicate the number of channels of the input tensor.",
          "isRequired": true,
          "type": "int"
        },
        "use_global_stats": {
          "def": "Whether to use global mean and variance. If set to False, use the statistics of one mini-batch, if set to True, use the global statistics, if set to None, use global statistics in the test phase and use the statistics of one mini-batch in the training phase. Default: None.",
          "isRequired": false,
          "type": "bool|None"
        },
        "weight_attr": {
          "def": "The parameter attribute for Parameter scale of batch_norm. If it is set to None or one attribute of ParamAttr, batch_norm will create ParamAttr as weight_attr. If it is set to False, the weight is not learnable. If the Initializer of the weight_attr is not set, the parameter is initialized with ones. Default: None.",
          "isRequired": false,
          "type": "ParamAttr|bool"
        }
      }
    },
    "pytorch": {
      "torch.nn.BatchNorm1d": {
        "affine": {
          "def": "a boolean value that when set to True, this module has learnable affine parameters",
          "isRequired": false,
          "type": "bool"
        },
        "eps": {
          "def": "a value added to the denominator for numerical stability",
          "isRequired": false,
          "type": "float"
        },
        "momentum": {
          "def": "the value used for the running_mean and running_var computation",
          "isRequired": false,
          "type": "float"
        },
        "num_features": {
          "def": "number of features or channels CCC of the input",
          "isRequired": true,
          "type": "int"
        },
        "track_running_stats": {
          "def": "a boolean value that when set to True, this module tracks the running mean and variance, and when set to False, this module does not track such statistics, and initializes statistics buffers running_mean and running_var as None",
          "isRequired": false,
          "type": "bool"
        }
      },
      "torch.nn.BatchNorm2d": {
        "affine": {
          "def": "a boolean value that when set to True, this module has learnable affine parameters",
          "isRequired": false,
          "type": "bool"
        },
        "eps": {
          "def": "a value added to the denominator for numerical stability",
          "isRequired": false,
          "type": "float"
        },
        "momentum": {
          "def": "the value used for the running_mean and running_var computation",
          "isRequired": false,
          "type": "float"
        },
        "num_features": {
          "def": "CCC from an expected input of size (N,C,H,W)(N, C, H, W)(N,C,H,W)",
          "isRequired": true,
          "type": "int"
        },
        "track_running_stats": {
          "def": "a boolean value that when set to True, this module tracks the running mean and variance, and when set to False, this module does not track such statistics, and initializes statistics buffers running_mean and running_var as None",
          "isRequired": false,
          "type": "bool"
        }
      },
      "torch.nn.BatchNorm3d": {
        "affine": {
          "def": "a boolean value that when set to True, this module has learnable affine parameters",
          "isRequired": false,
          "type": "bool"
        },
        "eps": {
          "def": "a value added to the denominator for numerical stability",
          "isRequired": false,
          "type": "float"
        },
        "momentum": {
          "def": "the value used for the running_mean and running_var computation",
          "isRequired": false,
          "type": "float"
        },
        "num_features": {
          "def": "CCC from an expected input of size (N,C,D,H,W)(N, C, D, H, W)(N,C,D,H,W)",
          "isRequired": true,
          "type": "int"
        },
        "track_running_stats": {
          "def": "a boolean value that when set to True, this module tracks the running mean and variance, and when set to False, this module does not track such statistics, and initializes statistics buffers running_mean and running_var as None",
          "isRequired": false,
          "type": "bool"
        }
      }
    },
    "tensorflow": {
      "tf.keras.layers.BatchNormalization": {
        "axis": {
          "def": "Integer, the axis that should be normalized (typically the features axis). For instance, after a Conv2D layer with data_format=\"channels_first\", set axis=1 in BatchNormalization.",
          "isRequired": false,
          "type": "int"
        },
        "beta_constraint": {
          "def": "Optional constraint for the beta weight.",
          "isRequired": false,
          "type": "string"
        },
        "beta_initializer": {
          "def": "Initializer for the beta weight.",
          "isRequired": false,
          "type": "string"
        },
        "beta_regularizer": {
          "def": "Optional regularizer for the beta weight.",
          "isRequired": false,
          "type": "string"
        },
        "center": {
          "def": "If True, add offset of beta to normalized tensor. If False, beta is ignored.",
          "isRequired": false,
          "type": "bool"
        },
        "epsilon": {
          "def": "Small float added to variance to avoid dividing by zero.",
          "isRequired": false,
          "type": "float"
        },
        "gamma_constraint": {
          "def": "Optional constraint for the gamma weight.",
          "isRequired": false,
          "type": "string"
        },
        "gamma_initializer": {
          "def": "Initializer for the gamma weight.",
          "isRequired": false,
          "type": "string"
        },
        "gamma_regularizer": {
          "def": "Optional regularizer for the gamma weight.",
          "isRequired": false,
          "type": "string"
        },
        "momentum": {
          "def": "Momentum for the moving average.",
          "isRequired": false,
          "type": "string"
        },
        "moving_mean_initializer": {
          "def": "Initializer for the moving mean.",
          "isRequired": false,
          "type": "string"
        },
        "moving_variance_initializer": {
          "def": "Initializer for the moving variance.",
          "isRequired": false,
          "type": "string"
        },
        "scale": {
          "def": "If True, multiply by gamma. If False, gamma is not used. When the next layer is linear (also e.g. nn.relu), this can be disabled since the scaling will be done by the next layer.",
          "isRequired": false,
          "type": "bool"
        },
        "synchronized": {
          "def": "If True, synchronizes the global batch statistics (mean and variance) for the layer across all devices at each training step in a distributed training strategy. If False, each replica uses its own local batch statistics. Only relevant when used inside a tf.distribute strategy.",
          "isRequired": false,
          "type": "bool"
        }
      }
    }
  },
  "Ceil": {
    "mindspore": {
      "mindspore.ops.ceil": {
        "input": {
          "def": "The input tensor with a dtype of float16 or float32.",
          "isRequired": true,
          "type": "tensor"
        }
      }
    },
    "onnx": {
      "consumed_inputs": {
        "def": "legacy optimization attribute.",
        "type": "ints"
      }
    },
    "paddlepaddle": {
      "paddle.ceil": {
        "name": {
          "def": "Name for the operation (optional, default is None). For more information, please refer to Name.",
          "isRequired": false,
          "type": "str"
        },
        "x": {
          "def": "Input of Ceil operator, an N-D tensor, with data type float32, float64 or float16.",
          "isRequired": true,
          "type": "tensor"
        }
      }
    },
    "pytorch": {
      "torch.ceil": {
        "input": {
          "def": "the input tensor",
          "isRequired": true,
          "type": "tensor"
        }
      }
    },
    "tensorflow": {
      "tf.math.ceil": {
        "name": {
          "def": "A name for the operation (optional).",
          "isRequired": false,
          "type": "string"
        },
        "x": {
          "def": "A tf.tensor. Must be one of the following types: bfloat16, half, float32, float64. int32",
          "isRequired": true,
          "type": "tensor"
        }
      }
    }
  },
  "Celu": {
    "mindspore": {
      "mindspore.nn.CELU": {
        "alpha": {
          "def": "The \n value for the Celu formulation. Default: 1.0 .",
          "isRequired": false,
          "type": "float"
        }
      }
    },
    "onnx": {
      "alpha": {
        "def": "The Alpha value in Celu formula which control the shape of the unit.The default value is 1.0.",
        "type": "float"
      }
    },
    "paddlepaddle": {
      "paddle.nn.CELU": {
        "alpha": {
          "def": "The \u2018alpha\u2019 value of the CELU formulation. Default is 1.0.",
          "isRequired": false,
          "type": "float"
        },
        "name": {
          "def": "Name for the operation (optional, default is None). For more information, please refer to Name.",
          "isRequired": false,
          "type": "str"
        }
      }
    },
    "pytorch": {
      "torch.nn.CELU": {
        "alpha": {
          "def": "the \u03b1\\alpha\u03b1 value for the CELU formulation",
          "isRequired": false,
          "type": "float"
        },
        "inplace": {
          "def": "can optionally do the operation in-place",
          "isRequired": false,
          "type": "bool"
        }
      }
    },
    "tensorflow": {}
  },
  "Concat": {
    "mindspore": {
      "mindspore.ops.cat": {
        "axis": {
          "def": "The specified axis, whose value is in range \\([-R, R)\\). Default: 0 .",
          "isRequired": false,
          "type": "int"
        },
        "tensors": {
          "def": "A tuple or a list of input tensors. Suppose there are two tensors in this tuple or list, namely t1 and t2. To perform concat in the axis 0 direction, except for the \\(0\\)-th axis, all other dimensions should be equal, that is, \\(t1.shape[1] = t2.shape[1], t1.shape[2] = t2.shape[2], ..., t1.shape[R-1] = t2.shape[R-1]\\), where \\(R\\) represents the rank of tensor.",
          "isRequired": true,
          "type": "tensors"
        }
      }
    },
    "onnx": {
      "axis": {
        "def": "Which axis to concat on",
        "type": "int"
      }
    },
    "paddlepaddle": {
      "paddle.concat": {
        "axis": {
          "def": "Specify the axis to operate on the input tensors. Tt should be integer or 0-D int tensor with shape []. The effective range is [-R, R), where R is Rank(x). When axis < 0, it works the same way as axis+R. Default is 0.",
          "isRequired": false,
          "type": "int|tensor"
        },
        "name": {
          "def": "Name for the operation (optional, default is None). For more information, please refer to Name.",
          "isRequired": false,
          "type": "str"
        },
        "x": {
          "def": "x is a tensor list or tensor tuple which is with data type bool, float16, float32, float64, int32, int64, int8, uint8. All the tensors in x must have same data type.",
          "isRequired": true,
          "type": "list|tuple"
        }
      }
    },
    "pytorch": {
      "torch.cat": {
        "dim": {
          "def": "the dimension over which the tensors are concatenated.",
          "isRequired": false,
          "type": "int"
        },
        "out": {
          "def": "the output tensor.",
          "isRequired": false,
          "type": "tensor"
        },
        "tensors": {
          "def": "any python sequence of tensors of the same type",
          "isRequired": true,
          "type": "tensors"
        }
      }
    },
    "tensorflow": {
      "tf.concat": {
        "axis": {
          "def": "0-D int32 tensor. Dimension along which to concatenate. Must be in the range [-rank(values), rank(values)). As in Python, indexing for axis is 0-based. Positive axis in the rage of [0, rank(values)) refers to axis-th dimension. And negative axis refers to axis + rank(values)-th dimension.",
          "isRequired": true,
          "type": "int"
        },
        "name": {
          "def": "A name for the operation (optional).",
          "isRequired": false,
          "type": "string"
        },
        "values": {
          "def": "A list of tensor objects or a single tensor.",
          "isRequired": true,
          "type": "tensors"
        }
      },
      "tf.keras.layers.Concatenate": {
        "axis": {
          "def": "Axis along which to concatenate.",
          "isRequired": false,
          "type": "int"
        }
      }
    }
  },
  "Conv": {
    "mindspore": {
      "mindspore.nn.Conv1d": {
        "bias_init": {
          "def": "Initialization method of bias parameter. Available initialization methods are the same as \u2018weight_init\u2019. Refer to the values of Initializer, for more details. Default: None , bias will be initialized using 'Uniform'.",
          "isRequired": false,
          "type": "Union[tensor, str, Initializer, numbers.Number]"
        },
        "dilation": {
          "def": "Specifies the dilation rate to use for dilated convolution. It can be a single int or a tuple of 1 integer. Assuming \\(dilation=(d0,)\\), the convolutional kernel samples the input with a spacing of \\(d0-1\\) elements in the width direction. The value should be in the ranges [1, L]. Default: 1 .",
          "isRequired": false,
          "type": "Union(int, tuple[int]"
        },
        "dtype": {
          "def": "Dtype of Parameters. Default: mstype.float32 .",
          "isRequired": false,
          "type": "mindspore.dtype"
        },
        "group": {
          "def": "Splits filter into groups, in_channels and out_channels must be divisible by group. Default: 1 .",
          "isRequired": false,
          "type": "int"
        },
        "has_bias": {
          "def": "Whether the Conv1d layer has a bias parameter. Default: False .",
          "isRequired": false,
          "type": "bool"
        },
        "in_channels": {
          "def": "The channel number of the input tensor of the Conv1d layer.",
          "isRequired": true,
          "type": "int"
        },
        "kernel_size": {
          "def": "Specifies the width of the 1D convolution kernel.",
          "isRequired": true,
          "type": "int"
        },
        "out_channels": {
          "def": "The channel number of the output tensor of the Conv1d layer.",
          "isRequired": true,
          "type": "int"
        },
        "pad_mode": {
          "def": "Specifies the padding mode with a padding value of 0. It can be set to: \"same\" , \"valid\" or \"pad\" . Default: \"same\" .  \"same\": Pad the input at the begin and end so that the shape of input and output are the same when stride is set to 1. The amount of padding to is calculated by the operator internally. If the amount is even, it is uniformly distributed around the input, if it is odd, the excess padding is goes to the right side. If this mode is set, padding must be 0. \"valid\": No padding is applied to the input, and the output returns the maximum possible length. Extra pixels that could not complete a full stride will be discarded. If this mode is set, padding must be 0. \"pad\": Pad the input with a specified amount. In this mode, the amount of padding at the begin and end is determined by the padding parameter. If this mode is set, padding must be greater than or equal to 0.",
          "isRequired": false,
          "type": "str"
        },
        "padding": {
          "def": "Specifies the amount of padding to apply on both side of input when pad_mode is set to \"pad\". The paddings of left and right are the same, equal to padding or padding[0] when padding is a tuple of 1 integer. Default: 0 .",
          "isRequired": false,
          "type": "Union(int, tuple[int], list[int]"
        },
        "stride": {
          "def": "The movement stride of the 1D convolution kernel. Default: 1 .",
          "isRequired": false,
          "type": "int"
        },
        "weight_init": {
          "def": "Initialization method of weight parameter. It can be a tensor, a string, an Initializer or a numbers.Number. When a string is specified, values from 'TruncatedNormal' , 'Normal' , 'Uniform' , 'HeUniform' and 'XavierUniform' distributions as well as constant \u2018One\u2019 and \u2018Zero\u2019 distributions are possible. Alias 'xavier_uniform' , 'he_uniform' , 'ones' and 'zeros' are acceptable. Uppercase and lowercase are both acceptable. Refer to the values of Initializer, for more details. Default: None , weight will be initialized using 'HeUniform'.",
          "isRequired": false,
          "type": "Union[tensor, str, Initializer, numbers.Number]"
        }
      },
      "mindspore.nn.Conv2d": {
        "bias_init": {
          "def": "Initialization method of bias parameter. Available initialization methods are the same as \u2018weight_init\u2019. Refer to the values of Initializer, for more details. Default: None , bias will be initialized using 'Uniform' .",
          "isRequired": false,
          "type": "Union[tensor, str, Initializer, numbers.Number]"
        },
        "data_format": {
          "def": "The optional value for data format, is 'NHWC' or 'NCHW' . Default: 'NCHW' .",
          "isRequired": false,
          "type": "str"
        },
        "dilation": {
          "def": "Specifies the dilation rate to use for dilated convolution. It can be a single int or a tuple of 2 or 4 integers. A single int means the dilation size is the same in both the height and width directions. A tuple of two ints represents the dilation size in the height and width directions, respectively. For a tuple of four ints, the two ints correspond to (N, C) dimension are treated as 1, and the two correspond to (H, W) dimensions is the dilation size in the height and width directions respectively. Assuming \\(dilation=(d0, d1)\\), the convolutional kernel samples the input with a spacing of \\(d0-1\\) elements in the height direction and \\(d1-1\\) elements in the width direction. The values in the height and width dimensions are in the ranges [1, H] and [1, W], respectively. Default: 1 .",
          "isRequired": false,
          "type": "Union(int, tuple[int]"
        },
        "dtype": {
          "def": "Dtype of Parameters. Default: mstype.float32 .",
          "isRequired": false,
          "type": "mindspore.dtype"
        },
        "group": {
          "def": "Splits filter into groups, in_channels and out_channels must be divisible by group. If the group is equal to in_channels and out_channels, this 2D convolution layer also can be called 2D depthwise convolution layer. Default: 1 .",
          "isRequired": false,
          "type": "int"
        },
        "has_bias": {
          "def": "Whether the Conv2d layer has a bias parameter. Default: False .",
          "isRequired": false,
          "type": "bool"
        },
        "in_channels": {
          "def": "The channel number of the input tensor of the Conv2d layer.",
          "isRequired": true,
          "type": "int"
        },
        "kernel_size": {
          "def": "Specifies the height and width of the 2D convolution kernel. The data type is an integer or a tuple of two integers. An integer represents the height and width of the convolution kernel. A tuple of two integers represents the height and width of the convolution kernel respectively.",
          "isRequired": true,
          "type": "Union[int, tuple[int]]"
        },
        "out_channels": {
          "def": "The channel number of the output tensor of the Conv2d layer.",
          "isRequired": true,
          "type": "int"
        },
        "pad_mode": {
          "def": "Specifies the padding mode with a padding value of 0. It can be set to: \"same\" , \"valid\" or \"pad\" . Default: \"same\" .  \"same\": Pad the input around its edges so that the shape of input and output are the same when stride is set to 1. The amount of padding to is calculated by the operator internally, If the amount is even, it is uniformly distributed around the input, if it is odd, the excess amount goes to the right/bottom side. If this mode is set, padding must be 0. \"valid\": No padding is applied to the input, and the output returns the maximum possible height and width. Extra pixels that could not complete a full stride will be discarded. If this mode is set, padding must be 0. \"pad\": Pad the input with a specified amount. In this mode, the amount of padding in the height and width directions is determined by the padding parameter. If this mode is set, padding must be greater than or equal to 0.",
          "isRequired": false,
          "type": "str"
        },
        "padding": {
          "def": "The number of padding on the height and width directions of the input. The data type is an integer or a tuple of four integers. If padding is an integer, then the top, bottom, left, and right padding are all equal to padding. If padding is a tuple of 4 integers, then the top, bottom, left, and right padding is equal to padding[0], padding[1], padding[2], and padding[3] respectively. The value should be greater than or equal to 0. Default: 0 .",
          "isRequired": false,
          "type": "Union[int, tuple[int]]"
        },
        "stride": {
          "def": "The movement stride of the 2D convolution kernel. The data type is an integer or a tuple of two or four integers. An integer represents the movement step size in both height and width directions. A tuple of two integers represents the movement step size in the height and width directions respectively. Default: 1 .",
          "isRequired": false,
          "type": "Union[int, tuple[int]]"
        },
        "weight_init": {
          "def": "Initialization method of weight parameter. It can be a tensor, a string, an Initializer or a numbers.Number. When a string is specified, values from 'TruncatedNormal' , 'Normal' , 'Uniform' , 'HeUniform' and 'XavierUniform' distributions as well as constant 'One' and 'Zero' distributions are possible. Alias 'xavier_uniform' , 'he_uniform' , 'ones' and 'zeros' are acceptable. Uppercase and lowercase are both acceptable. Refer to the values of Initializer, for more details. Default: None , weight will be initialized using 'HeUniform'.",
          "isRequired": false,
          "type": "Union[tensor, str, Initializer, numbers.Number]"
        }
      },
      "mindspore.nn.Conv3d": {
        "bias_init": {
          "def": "Initialization method of bias parameter. Available initialization methods are the same as \u2018weight_init\u2019. Refer to the values of Initializer, for more details. Default: None , bias will be initialized using 'Uniform' .",
          "isRequired": false,
          "type": "Union[tensor, str, Initializer, numbers.Number]"
        },
        "data_format": {
          "def": "The optional value for data format. Currently only support 'NCDHW' .",
          "isRequired": false,
          "type": "str"
        },
        "dilation": {
          "def": "Specifies the dilation rate to use for dilated convolution. It can be a single int or a tuple of 3 integers. A single int means the dilation size is the same in the depth, height and width directions. A tuple of 3 ints represents the dilation size in the depth, height and width directions, respectively. Assuming \\(dilation=(d0, d1, d2)\\), the convolutional kernel samples the input with a spacing of \\(d0-1\\) elements in the depth direction, \\(d1-1\\) elements in the height direction, \\(d2-1\\) elements in the width direction respectively. The values in the depth, height and width dimensions are in the ranges [1, D], [1, H] and [1, W], respectively. Default: 1 .",
          "isRequired": false,
          "type": "Union[int, tuple[int]]"
        },
        "dtype": {
          "def": "Dtype of Parameters. Default: mstype.float32 .",
          "isRequired": false,
          "type": "mindspore.dtype"
        },
        "group": {
          "def": "Splits filter into groups, in_channels and out_channels must be divisible by group. Default: 1 .",
          "isRequired": false,
          "type": "int"
        },
        "has_bias": {
          "def": "Whether the Conv3d layer has a bias parameter. Default: False .",
          "isRequired": false,
          "type": "bool"
        },
        "in_channels": {
          "def": "The channel number of the input tensor of the Conv3d layer.",
          "isRequired": true,
          "type": "int"
        },
        "kernel_size": {
          "def": "Specifies the depth, height and width of the 3D convolution kernel. It can be a single int or a tuple of 3 integers. A single int means the value is for depth, height and the width. A tuple of 3 ints means the first value is for depth and the rest is for the height and width.",
          "isRequired": true,
          "type": "Union[int, tuple[int]]"
        },
        "out_channels": {
          "def": "The channel number of the output tensor of the Conv3d layer.",
          "isRequired": true,
          "type": "int"
        },
        "pad_mode": {
          "def": "Specifies the padding mode with a padding value of 0. It can be set to: \"same\" , \"valid\" or \"pad\" . Default: \"same\" .  \"same\": Pad the input around its depth/height/width dimension so that the shape of input and output are the same when stride is set to 1. The amount of padding to is calculated by the operator internally.  If the amount is even, it isuniformly distributed around the input, if it is odd, the excess amount goes to the front/right/bottom side. If this mode is set, padding must be 0. \"valid\": No padding is applied to the input, and the output returns the maximum possible depth, height and width. Extra pixels that could not complete a full stride will be discarded. If this mode is set, padding must be 0. \"pad\": Pad the input with a specified amount. In this mode, the amount of padding in the depth, height and width dimension is determined by the padding parameter. If this mode is set, padding must be greater than or equal to 0.",
          "isRequired": false,
          "type": "str"
        },
        "padding": {
          "def": "The number of padding on the depth, height and width directions of the input. The data type is an integer or a tuple of six integers. If padding is an integer, then the head, tail, top, bottom, left, and right padding are all equal to padding. If padding is a tuple of six integers, then the head, tail, top, bottom, left, and right padding is equal to padding[0], padding[1], padding[2], padding[3], padding[4] and padding[5] respectively. The value should be greater than or equal to 0. Default: 0 .",
          "isRequired": false,
          "type": "Union(int, tuple[int]"
        },
        "stride": {
          "def": "The movement stride of the 3D convolution kernel. The data type is an integer or a tuple of three integers. An integer represents the movement step size in depth, height and width directions. A tuple of three integers represents the movement step size in the depth, height and width directions respectively. Default: 1 .",
          "isRequired": false,
          "type": "Union[int, tuple[int]]"
        },
        "weight_init": {
          "def": "Initialization method of weight parameter. It can be a tensor, a string, an Initializer or a numbers.Number. When a string is specified, values from 'TruncatedNormal' , 'Normal' , 'Uniform' , 'HeUniform' and 'XavierUniform' distributions as well as constant 'One' and 'Zero' distributions are possible. Alias 'xavier_uniform' , 'he_uniform' , 'ones' and 'zeros' are acceptable. Uppercase and lowercase are both acceptable. Refer to the values of Initializer, for more details. Default: None , weight will be initialized using 'HeUniform'.",
          "isRequired": false,
          "type": "Union[tensor, str, Initializer, numbers.Number]"
        }
      }
    },
    "onnx": {
      "auto_pad": {
        "def": "auto_pad must be either NOTSET, SAME_UPPER, SAME_LOWER or VALID.Where default value is NOTSET, which means explicit padding is used.SAME_UPPER or SAME_LOWER mean pad the input so that output_shape[i] = ceil(input_shape[i] / strides[i]) for each axis i",
        "type": "string"
      },
      "dilations": {
        "def": "dilation value along each spatial axis of the filter",
        "type": "ints"
      },
      "group": {
        "def": "number of groups input channels and output channels are dividedinto.",
        "type": "int"
      },
      "kernel_shape": {
        "def": "The shape of the convolution kernel",
        "type": "ints"
      },
      "pads": {
        "def": "Padding for the beginning and ending along each spatial axis, it cantake any value greater than or equal to 0",
        "type": "ints"
      },
      "strides": {
        "def": "Stride along each spatial axis",
        "type": "ints"
      }
    },
    "paddlepaddle": {
      "paddle.nn.Conv1D": {
        "bias_attr": {
          "def": "The attribute for the bias of conv1d. If it is set to False, no bias will be added to the output units. If it is set to None or one attribute of ParamAttr, conv1d will create ParamAttr as bias_attr. If the Initializer of the bias_attr is not set, the bias is initialized zero. Default: None.",
          "isRequired": false,
          "type": "ParamAttr or bool"
        },
        "dilation": {
          "def": "The dilation size. If dilation is a tuple/list, it must contain one integer, (dilation_size). Default: 1.",
          "isRequired": false,
          "type": "int|tuple|list"
        },
        "groups": {
          "def": "The groups number of the conv2d Layer. According to grouped convolution in Alex Krizhevsky\u2019s Deep CNN paper: when group=2, the first half of the filters is only connected to the first half of the input channels, while the second half of the filters is only connected to the second half of the input channels. Default: 1.",
          "isRequired": false,
          "type": "int"
        },
        "in_channels": {
          "def": "The number of channels in the input image.",
          "isRequired": true,
          "type": "int"
        },
        "kernel_size": {
          "def": "The filter size. If kernel_size is a tuple/list, it must contain one integer, (kernel_size).",
          "isRequired": true,
          "type": "int|tuple|list"
        },
        "out_channels": {
          "def": "The number of filter. It is as same as the output feature map.",
          "isRequired": true,
          "type": "int"
        },
        "padding": {
          "def": "The size of zeros to be padded. It must be in one of the following forms. 1. a string in [\u2018valid\u2019, \u2018same\u2019]. 2. an int, which means the feature map is zero paded by size of padding on both sides. 3. a list[int] or tuple[int] whose length is 1, which means the feature map is zero paded by size of padding[0] on both sides. The default value is 0.",
          "isRequired": false,
          "type": "int|str|tuple|list"
        },
        "padding_mode": {
          "def": "Four modes: \u2018zeros\u2019, \u2018reflect\u2019, \u2018replicate\u2019, \u2018circular\u2019. When in \u2018zeros\u2019 mode, this op uses zeros to pad the input tensor. When in \u2018reflect\u2019 mode, uses reflection of the input boundaries to pad the input tensor. When in \u2018replicate\u2019 mode, uses input boundaries to pad the input tensor. When in \u2018circular\u2019 mode, uses circular input to pad the input tensor. Default is \u2018zeros\u2019.",
          "isRequired": false,
          "type": "str"
        },
        "stride": {
          "def": "The stride size. If stride is a tuple/list, it must contain one integer, (stride_size). Default: 1.",
          "isRequired": false,
          "type": "int|tuple|list"
        },
        "weight_attr": {
          "def": "The parameter attribute for learnable weights(Parameter) of conv1d. If it is set to None or one attribute of ParamAttr, conv1d will create ParamAttr as param_attr. If the Initializer of the param_attr is not set, the parameter is initialized with \\(Normal(0.0, std)\\), and the \\(std\\) is \\((\\frac{2.0 }{filter\\_elem\\_num})^{0.5}\\). Default: None.",
          "isRequired": false,
          "type": "ParamAttr"
        }
      },
      "paddle.nn.Conv2D": {
        "bias_attr": {
          "def": "The parameter attribute for the bias of conv2d. If it is set to False, no bias will be added to the output units. If it is set to None or one attribute of ParamAttr, conv2d will create ParamAttr as bias_attr. If the Initializer of the bias_attr is not set, the bias is initialized zero. The default value is None.",
          "isRequired": false,
          "type": "ParamAttr|bool"
        },
        "data_format": {
          "def": "Data format that specifies the layout of input. It can be \u201cNCHW\u201d or \u201cNHWC\u201d. Default: \u201cNCHW\u201d.",
          "isRequired": false,
          "type": "str"
        },
        "dilation": {
          "def": "The dilation size. If dilation is a list/tuple, it must contain two integers, (dilation_H, dilation_W). Otherwise, the dilation_H = dilation_W = dilation. The default value is 1.",
          "isRequired": false,
          "type": "int|list|tuple"
        },
        "groups": {
          "def": "The groups number of the Conv2D Layer. According to grouped convolution in Alex Krizhevsky\u2019s Deep CNN paper: when group=2, the first half of the filters is only connected to the first half of the input channels, while the second half of the filters is only connected to the second half of the input channels. The default value is 1.",
          "isRequired": false,
          "type": "int"
        },
        "in_channels": {
          "def": "The number of input channels in the input image.",
          "isRequired": true,
          "type": "int"
        },
        "kernel_size": {
          "def": "The size of the convolving kernel.",
          "isRequired": true,
          "type": "int|list|tuple"
        },
        "out_channels": {
          "def": "The number of output channels produced by the convolution.",
          "isRequired": true,
          "type": "int"
        },
        "padding": {
          "def": "The padding size. Padding coule be in one of the following forms. 1. a string in [\u2018valid\u2019, \u2018same\u2019]. 2. an int, which means each spartial dimension(depth, height, width) is zero paded by size of padding 3. a list[int] or tuple[int] whose length is the number of spartial dimensions, which contains the amount of padding on each side for each spartial dimension. It has the form [pad_d1, pad_d2, \u2026]. 4. a list[int] or tuple[int] whose length is 2 * number of spartial dimensions. It has the form [pad_before, pad_after, pad_before, pad_after, \u2026] for all spartial dimensions. 5. a list or tuple of pairs of ints. It has the form [[pad_before, pad_after], [pad_before, pad_after], \u2026]. Note that, the batch dimension and channel dimension are also included. Each pair of integers correspond to the amount of padding for a dimension of the input. Padding in batch dimension and channel dimension should be [0, 0] or (0, 0). The default value is 0.",
          "isRequired": false,
          "type": "int|str|tuple|list"
        },
        "padding_mode": {
          "def": "'zeros', 'reflect', 'replicate' or 'circular'. Default: 'zeros'.",
          "isRequired": false,
          "type": "str"
        },
        "stride": {
          "def": "The stride size. If stride is a list/tuple, it must contain two integers, (stride_H, stride_W). Otherwise, the stride_H = stride_W = stride. The default value is 1.",
          "isRequired": false,
          "type": "int|list|tuple"
        },
        "weight_attr": {
          "def": "The parameter attribute for learnable parameters/weights of conv2d. If it is set to None or one attribute of ParamAttr, conv2d will create ParamAttr as param_attr. If it is set to None, the parameter is initialized with \\(Normal(0.0, std)\\), and the \\(std\\) is \\((\\frac{2.0 }{filter\\_elem\\_num})^{0.5}\\). The default value is None.",
          "isRequired": false,
          "type": "ParamAttr"
        }
      },
      "paddle.nn.Conv3D": {
        "bias_attr": {
          "def": "The parameter attribute for the bias of conv3d. If it is set to False, no bias will be added to the output units. If it is set to None or one attribute of ParamAttr, conv3d will create ParamAttr as bias_attr. If the Initializer of the bias_attr is not set, the bias is initialized zero. The default value is None.",
          "isRequired": false,
          "type": "ParamAttr|bool"
        },
        "data_format": {
          "def": "Data format that specifies the layout of input. It can be \u201cNCDHW\u201d or \u201cNDHWC\u201d. Default: \u201cNCDHW\u201d.",
          "isRequired": false,
          "type": "str"
        },
        "dilation": {
          "def": "The dilation size. If dilation is a list/tuple, it must contain three integers, (dilation_D, dilation_H, dilation_W). Otherwise, the dilation_D = dilation_H = dilation_W = dilation. The default value is 1.",
          "isRequired": false,
          "type": "int|list|tuple"
        },
        "groups": {
          "def": "The groups number of the Conv3D Layer. According to grouped convolution in Alex Krizhevsky\u2019s Deep CNN paper: when group=2, the first half of the filters is only connected to the first half of the input channels, while the second half of the filters is only connected to the second half of the input channels. The default value is 1.",
          "isRequired": false,
          "type": "int"
        },
        "in_channels": {
          "def": "The number of input channels in the input image.",
          "isRequired": true,
          "type": "int"
        },
        "kernel_size": {
          "def": "The size of the convolving kernel.",
          "isRequired": true,
          "type": "int|list|tuple"
        },
        "out_channels": {
          "def": "The number of output channels produced by the convolution.",
          "isRequired": true,
          "type": "int"
        },
        "padding": {
          "def": "The padding size. Padding coule be in one of the following forms. 1. a string in [\u2018valid\u2019, \u2018same\u2019]. 2. an int, which means each spartial dimension(depth, height, width) is zero paded by size of padding 3. a list[int] or tuple[int] whose length is the number of spartial dimensions, which contains the amount of padding on each side for each spartial dimension. It has the form [pad_d1, pad_d2, \u2026]. 4. a list[int] or tuple[int] whose length is 2 * number of spartial dimensions. It has the form [pad_before, pad_after, pad_before, pad_after, \u2026] for all spartial dimensions. 5. a list or tuple of pairs of ints. It has the form [[pad_before, pad_after], [pad_before, pad_after], \u2026]. Note that, the batch dimension and channel dimension are also included. Each pair of integers correspond to the amount of padding for a dimension of the input. Padding in batch dimension and channel dimension should be [0, 0] or (0, 0). The default value is 0.",
          "isRequired": false,
          "type": "int|str|tuple|list"
        },
        "padding_mode": {
          "def": "'zeros', 'reflect', 'replicate' or 'circular'. Default: 'zeros'.",
          "isRequired": false,
          "type": "str"
        },
        "stride": {
          "def": "The stride size. If stride is a list/tuple, it must contain three integers, (stride_D, stride_H, stride_W). Otherwise, the stride_D = stride_H = stride_W = stride. The default value is 1.",
          "isRequired": false,
          "type": "int|list|tuple"
        },
        "weight_attr": {
          "def": "The parameter attribute for learnable parameters/weights of conv3d. If it is set to None or one attribute of ParamAttr, conv3d will create ParamAttr as param_attr. If it is set to None, the parameter is initialized with \\(Normal(0.0, std)\\), and the \\(std\\) is \\((\\frac{2.0 }{filter\\_elem\\_num})^{0.5}\\). The default value is None.",
          "isRequired": false,
          "type": "ParamAttr"
        }
      }
    },
    "pytorch": {
      "torch.nn.Conv1d": {
        "bias": {
          "def": "If True, adds a learnable bias to the output",
          "isRequired": false,
          "type": "bool"
        },
        "dilation": {
          "def": "Spacing between kernel elements",
          "isRequired": false,
          "type": "ints"
        },
        "groups": {
          "def": "Number of blocked connections from input channels to output channels",
          "isRequired": false,
          "type": "int"
        },
        "in_channels": {
          "def": "Number of channels in the input image",
          "isRequired": true,
          "type": "int"
        },
        "kernel_size": {
          "def": "Size of the convolving kernel",
          "isRequired": true,
          "type": "ints"
        },
        "out_channels": {
          "def": "Number of channels produced by the convolution",
          "isRequired": true,
          "type": "int"
        },
        "padding": {
          "def": "Padding added to both sides of the input",
          "isRequired": false,
          "type": "ints"
        },
        "padding_mode": {
          "def": "'zeros', 'reflect', 'replicate' or 'circular'",
          "isRequired": false,
          "type": "string"
        },
        "stride": {
          "def": "Stride of the convolution",
          "isRequired": false,
          "type": "ints"
        }
      },
      "torch.nn.Conv2d": {
        "bias": {
          "def": "If True, adds a learnable bias to the output",
          "isRequired": false,
          "type": "bool"
        },
        "dilation": {
          "def": "Spacing between kernel elements",
          "isRequired": false,
          "type": "ints"
        },
        "groups": {
          "def": "Number of blocked connections from input channels to output channels",
          "isRequired": false,
          "type": "int"
        },
        "in_channels": {
          "def": "Number of channels in the input image",
          "isRequired": true,
          "type": "int"
        },
        "kernel_size": {
          "def": "Size of the convolving kernel",
          "isRequired": true,
          "type": "ints"
        },
        "out_channels": {
          "def": "Number of channels produced by the convolution",
          "isRequired": true,
          "type": "int"
        },
        "padding": {
          "def": "Padding added to all four sides of the input",
          "isRequired": false,
          "type": "int tuple or str"
        },
        "padding_mode": {
          "def": "'zeros', 'reflect', 'replicate' or 'circular'",
          "isRequired": false,
          "type": "string"
        },
        "stride": {
          "def": "Stride of the convolution",
          "isRequired": false,
          "type": "ints"
        }
      },
      "torch.nn.Conv3d": {
        "bias": {
          "def": "If True, adds a learnable bias to the output",
          "isRequired": false,
          "type": "bool"
        },
        "dilation": {
          "def": "Spacing between kernel elements",
          "isRequired": false,
          "type": "ints"
        },
        "groups": {
          "def": "Number of blocked connections from input channels to output channels",
          "isRequired": false,
          "type": "int"
        },
        "in_channels": {
          "def": "Number of channels in the input image",
          "isRequired": true,
          "type": "int"
        },
        "kernel_size": {
          "def": "Size of the convolving kernel",
          "isRequired": true,
          "type": "ints"
        },
        "out_channels": {
          "def": "Number of channels produced by the convolution",
          "isRequired": true,
          "type": "int"
        },
        "padding": {
          "def": "Padding added to all six sides of the input",
          "isRequired": false,
          "type": "int tuple or str"
        },
        "padding_mode": {
          "def": "'zeros', 'reflect', 'replicate' or 'circular'",
          "isRequired": false,
          "type": "string"
        },
        "stride": {
          "def": "Stride of the convolution",
          "isRequired": false,
          "type": "ints"
        }
      }
    },
    "tensorflow": {
      "tf.keras.layers.Conv1D": {
        "activation": {
          "def": "Activation function to use. If you don't specify anything, no activation is applied (see keras.activations).",
          "isRequired": false,
          "type": "string"
        },
        "activity_regularizer": {
          "def": "Regularizer function applied to the output of the layer (its \"activation\") (see keras.regularizers).",
          "isRequired": false,
          "type": "string"
        },
        "bias_constraint": {
          "def": "Constraint function applied to the bias vector (see keras.constraints).",
          "isRequired": false,
          "type": "string"
        },
        "bias_initializer": {
          "def": "Initializer for the bias vector (see keras.initializers). Defaults to 'zeros'.",
          "isRequired": false,
          "type": "string"
        },
        "bias_regularizer": {
          "def": "Regularizer function applied to the bias vector (see keras.regularizers).",
          "isRequired": false,
          "type": "string"
        },
        "data_format": {
          "def": "A string, one of channels_last (default) or channels_first. The ordering of the dimensions in the inputs. channels_last corresponds to inputs with shape (batch_size, width, channels) while channels_first corresponds to inputs with shape (batch_size, channels, width). Note that the channels_first format is currently not supported by tensorFlow on CPU.",
          "isRequired": false,
          "type": "string"
        },
        "dilation_rate": {
          "def": "an integer or tuple/list of a single integer, specifying the dilation rate to use for dilated convolution. Currently, specifying any dilation_rate value != 1 is incompatible with specifying any strides value != 1.",
          "isRequired": false,
          "type": "int"
        },
        "filters": {
          "def": "Integer, the dimensionality of the output space (i.e. the number of output filters in the convolution).",
          "isRequired": true,
          "type": "int"
        },
        "groups": {
          "def": "A positive integer specifying the number of groups in which the input is split along the channel axis. Each group is convolved separately with filters / groups filters. The output is the concatenation of all the groups results along the channel axis. Input channels and filters must both be divisible by groups.",
          "isRequired": false,
          "type": "int"
        },
        "kernel_constraint": {
          "def": "Constraint function applied to the kernel matrix (see keras.constraints).",
          "isRequired": false,
          "type": "string"
        },
        "kernel_initializer": {
          "def": "Initializer for the kernel weights matrix (see keras.initializers). Defaults to 'glorot_uniform'.",
          "isRequired": false,
          "type": "string"
        },
        "kernel_regularizer": {
          "def": "Regularizer function applied to the kernel weights matrix (see keras.regularizers).",
          "isRequired": false,
          "type": "string"
        },
        "kernel_size": {
          "def": "An integer or tuple/list of a single integer, specifying the length of the 1D convolution window.",
          "isRequired": true,
          "type": "int"
        },
        "padding": {
          "def": "One of \"valid\", \"same\" or \"causal\" (case-insensitive). \"valid\" means no padding. \"same\" results in padding with zeros evenly to the left/right or up/down of the input such that output has the same height/width dimension as the input. \"causal\" results in causal (dilated) convolutions, e.g. output[t] does not depend on input[t+1:]. Useful when modeling temporal data where the model should not violate the temporal order. See WaveNet: A Generative Model for Raw Audio, section  2.1.",
          "isRequired": false,
          "type": "string"
        },
        "strides": {
          "def": "An integer or tuple/list of a single integer, specifying the stride length of the convolution. Specifying any stride value != 1 is incompatible with specifying any dilation_rate value != 1.",
          "isRequired": false,
          "type": "int"
        },
        "use_bias": {
          "def": "Boolean, whether the layer uses a bias vector.",
          "isRequired": false,
          "type": "bool"
        }
      },
      "tf.keras.layers.Conv2D": {
        "activation": {
          "def": "Activation function to use. If you don't specify anything, no activation is applied (see keras.activations).",
          "isRequired": false,
          "type": "string"
        },
        "activity_regularizer": {
          "def": "Regularizer function applied to the output of the layer (its \"activation\") (see keras.regularizers).",
          "isRequired": false,
          "type": "string"
        },
        "bias_constraint": {
          "def": "Constraint function applied to the bias vector (see keras.constraints).",
          "isRequired": false,
          "type": "string"
        },
        "bias_initializer": {
          "def": "Initializer for the bias vector (see keras.initializers). Defaults to 'zeros'.",
          "isRequired": false,
          "type": "string"
        },
        "bias_regularizer": {
          "def": "Regularizer function applied to the bias vector (see keras.regularizers).",
          "isRequired": false,
          "type": "string"
        },
        "data_format": {
          "def": "A string, one of channels_last (default) or channels_first. The ordering of the dimensions in the inputs. channels_last corresponds to inputs with shape (batch_size, height, width, channels) while channels_first corresponds to inputs with shape (batch_size, channels, height, width). If left unspecified, it uses the image_data_format value found in your Keras config file at ~/.keras/keras.json (if exists) else 'channels_last'. Note that the channels_first format is currently not supported by tensorFlow on CPU. Defaults to 'channels_last'.",
          "isRequired": false,
          "type": "string"
        },
        "dilation_rate": {
          "def": "an integer or tuple/list of 2 integers, specifying the dilation rate to use for dilated convolution. Can be a single integer to specify the same value for all spatial dimensions. Currently, specifying any dilation_rate value != 1 is incompatible with specifying any stride value != 1.",
          "isRequired": false,
          "type": "int"
        },
        "filters": {
          "def": "Integer, the dimensionality of the output space (i.e. the number of output filters in the convolution).",
          "isRequired": true,
          "type": "int"
        },
        "groups": {
          "def": "A positive integer specifying the number of groups in which the input is split along the channel axis. Each group is convolved separately with filters / groups filters. The output is the concatenation of all the groups results along the channel axis. Input channels and filters must both be divisible by groups.",
          "isRequired": false,
          "type": "int"
        },
        "kernel_constraint": {
          "def": "Constraint function applied to the kernel matrix (see keras.constraints).",
          "isRequired": false,
          "type": "string"
        },
        "kernel_initializer": {
          "def": "Initializer for the kernel weights matrix (see keras.initializers). Defaults to 'glorot_uniform'.",
          "isRequired": false,
          "type": "string"
        },
        "kernel_regularizer": {
          "def": "Regularizer function applied to the kernel weights matrix (see keras.regularizers).",
          "isRequired": false,
          "type": "string"
        },
        "kernel_size": {
          "def": "An integer or tuple/list of 2 integers, specifying the height and width of the 2D convolution window. Can be a single integer to specify the same value for all spatial dimensions.",
          "isRequired": true,
          "type": "int"
        },
        "padding": {
          "def": "one of \"valid\" or \"same\" (case-insensitive). \"valid\" means no padding. \"same\" results in padding with zeros evenly to the left/right or up/down of the input. When padding=\"same\" and strides=1, the output has the same size as the input.",
          "isRequired": false,
          "type": "string"
        },
        "strides": {
          "def": "An integer or tuple/list of 2 integers, specifying the strides of the convolution along the height and width. Can be a single integer to specify the same value for all spatial dimensions. Specifying any stride value != 1 is incompatible with specifying any dilation_rate value != 1.",
          "isRequired": false,
          "type": "int"
        },
        "use_bias": {
          "def": "Boolean, whether the layer uses a bias vector.",
          "isRequired": false,
          "type": "bool"
        }
      },
      "tf.keras.layers.Conv3D": {
        "activation": {
          "def": "Activation function to use. If you don't specify anything, no activation is applied (see keras.activations).",
          "isRequired": false,
          "type": "string"
        },
        "activity_regularizer": {
          "def": "Regularizer function applied to the output of the layer (its \"activation\") (see keras.regularizers).",
          "isRequired": false,
          "type": "string"
        },
        "bias_constraint": {
          "def": "Constraint function applied to the bias vector (see keras.constraints).",
          "isRequired": false,
          "type": "string"
        },
        "bias_initializer": {
          "def": "Initializer for the bias vector (see keras.initializers). Defaults to 'zeros'.",
          "isRequired": false,
          "type": "string"
        },
        "bias_regularizer": {
          "def": "Regularizer function applied to the bias vector (see keras.regularizers).",
          "isRequired": false,
          "type": "string"
        },
        "data_format": {
          "def": "A string, one of channels_last (default) or channels_first. The ordering of the dimensions in the inputs. channels_last corresponds to inputs with shape batch_shape + (spatial_dim1, spatial_dim2, spatial_dim3, channels) while channels_first corresponds to inputs with shape batch_shape + (channels, spatial_dim1, spatial_dim2, spatial_dim3). When unspecified, uses image_data_format value found in your Keras config file at ~/.keras/keras.json (if exists) else 'channels_last'. Note that the channels_first format is currently not supported by tensorFlow on CPU. Defaults to 'channels_last'.",
          "isRequired": false,
          "type": "string"
        },
        "dilation_rate": {
          "def": "an integer or tuple/list of 3 integers, specifying the dilation rate to use for dilated convolution. Can be a single integer to specify the same value for all spatial dimensions. Currently, specifying any dilation_rate value != 1 is incompatible with specifying any stride value != 1.",
          "isRequired": false,
          "type": "int"
        },
        "filters": {
          "def": "Integer, the dimensionality of the output space (i.e. the number of output filters in the convolution).",
          "isRequired": true,
          "type": "int"
        },
        "groups": {
          "def": "A positive integer specifying the number of groups in which the input is split along the channel axis. Each group is convolved separately with filters / groups filters. The output is the concatenation of all the groups results along the channel axis. Input channels and filters must both be divisible by groups.",
          "isRequired": false,
          "type": "int"
        },
        "kernel_constraint": {
          "def": "Constraint function applied to the kernel matrix (see keras.constraints).",
          "isRequired": false,
          "type": "string"
        },
        "kernel_initializer": {
          "def": "Initializer for the kernel weights matrix (see keras.initializers). Defaults to 'glorot_uniform'.",
          "isRequired": false,
          "type": "string"
        },
        "kernel_regularizer": {
          "def": "Regularizer function applied to the kernel weights matrix (see keras.regularizers).",
          "isRequired": false,
          "type": "string"
        },
        "kernel_size": {
          "def": "An integer or tuple/list of 3 integers, specifying the depth, height and width of the 3D convolution window. Can be a single integer to specify the same value for all spatial dimensions.",
          "isRequired": true,
          "type": "int"
        },
        "padding": {
          "def": "one of \"valid\" or \"same\" (case-insensitive). \"valid\" means no padding. \"same\" results in padding with zeros evenly to the left/right or up/down of the input such that output has the same height/width dimension as the input.",
          "isRequired": false,
          "type": "string"
        },
        "strides": {
          "def": "An integer or tuple/list of 3 integers, specifying the strides of the convolution along each spatial dimension. Can be a single integer to specify the same value for all spatial dimensions. Specifying any stride value != 1 is incompatible with specifying any dilation_rate value != 1.",
          "isRequired": false,
          "type": "int"
        },
        "use_bias": {
          "def": "Boolean, whether the layer uses a bias vector.",
          "isRequired": false,
          "type": "bool"
        }
      }
    }
  },
  "ConvTranspose": {
    "mindspore": {
      "mindspore.nn.Conv1dTranspose": {
        "bias_init": {
          "def": "Initialization method of bias parameter. Available initialization methods are the same as \u2018weight_init\u2019. Refer to the values of Initializer for more details. Default: None , bias will be initialized using Uniform.",
          "isRequired": false,
          "type": "Union[tensor, str, Initializer, numbers.Number]"
        },
        "dilation": {
          "def": "Dilation size of 1D convolution kernel. If \\(k > 1\\), the kernel is sampled every k elements. The value of k is in range of [1, L]. Default: 1 .",
          "isRequired": false,
          "type": "int"
        },
        "dtype": {
          "def": "Dtype of Parameters. Default: mstype.float32 .",
          "isRequired": false,
          "type": "mindspore.dtype"
        },
        "group": {
          "def": "Splits filter into groups, in_channels and out_channels must be divisible by group. When group > 1, the Ascend platform is not supported yet. Default: 1 .",
          "isRequired": false,
          "type": "int"
        },
        "has_bias": {
          "def": "Whether the Conv1dTranspose layer has a bias parameter. Default: False.",
          "isRequired": false,
          "type": "bool"
        },
        "in_channels": {
          "def": "The channel number of the input tensor of the Conv1dTranspose layer.",
          "isRequired": true,
          "type": "int"
        },
        "kernel_size": {
          "def": "Specifies the width of the 1D convolution kernel.",
          "isRequired": true,
          "type": "int"
        },
        "out_channels": {
          "def": "The channel number of the output tensor of the Conv1dTranspose layer.",
          "isRequired": true,
          "type": "int"
        },
        "pad_mode": {
          "def": "Specifies the padding mode with a padding value of 0. It can be set to: \"same\" , \"valid\" or \"pad\" . Default: \"same\" .  \"same\": Pad the input at the begin and end so that the shape of input and output are the same when stride is set to 1. The amount of padding to is calculated by the operator internally. If the amount is even, it is uniformly distributed around the input, if it is odd, the excess padding is goes to the right side. If this mode is set, padding must be 0. \"valid\": No padding is applied to the input, and the output returns the maximum possible length. Extra pixels that could not complete a full stride will be discarded. If this mode is set, padding must be 0. \"pad\": Pad the input with a specified amount. In this mode, the amount of padding at the begin and end is determined by the padding parameter. If this mode is set, padding must be greater than or equal to 0.",
          "isRequired": false,
          "type": "str"
        },
        "padding": {
          "def": "The number of padding on both sides of input. The value should be greater than or equal to 0. Default: 0 .",
          "isRequired": false,
          "type": "int"
        },
        "stride": {
          "def": "The movement stride of the 1D convolution kernel. Default: 1 .",
          "isRequired": false,
          "type": "int"
        },
        "weight_init": {
          "def": "Initialization method of weight parameter. It can be a tensor, a string, an Initializer or a numbers.Number. When a string is specified, values from 'TruncatedNormal' , 'Normal' , 'Uniform' , 'HeUniform' and 'XavierUniform' distributions as well as constant 'One' and 'Zero' distributions are possible. Alias 'xavier_uniform' , 'he_uniform', 'ones' and 'zeros' are acceptable. Uppercase and lowercase are both acceptable. Refer to the values of Initializer for more details. Default: None , weight will be initialized using HeUniform.",
          "isRequired": false,
          "type": "Union[tensor, str, Initializer, numbers.Number]"
        }
      },
      "mindspore.nn.Conv2dTranspose": {
        "bias_init": {
          "def": "Initialization method of bias parameter. Available initialization methods are the same as \u2018weight_init\u2019. Refer to the values of Initializer for more details. Default: None , bias will be initialized using Uniform.",
          "isRequired": false,
          "type": "Union[tensor, str, Initializer, numbers.Number]"
        },
        "dilation": {
          "def": "Dilation size of 2D convolution kernel. The data type is an integer or a tuple of two integers. If \\(k > 1\\), the kernel is sampled every k elements. The value of k on the height and width directions is in range of [1, H] and [1, W] respectively. Default: 1 .",
          "isRequired": false,
          "type": "Union[int, tuple[int]]"
        },
        "dtype": {
          "def": "Dtype of Parameters. Default: mstype.float32 .",
          "isRequired": false,
          "type": "mindspore.dtype"
        },
        "group": {
          "def": "Splits filter into groups, in_channels and out_channels must be divisible by group. Default: 1 .",
          "isRequired": false,
          "type": "int"
        },
        "has_bias": {
          "def": "Whether the Conv2dTranspose layer has a bias parameter. Default: False .",
          "isRequired": false,
          "type": "bool"
        },
        "in_channels": {
          "def": "The channel number of the input tensor of the Conv2dTranspose layer.",
          "isRequired": true,
          "type": "int"
        },
        "kernel_size": {
          "def": "Specifies the height and width of the 2D convolution kernel. The data type is an integer or a tuple of two integers. An integer represents the height and width of the convolution kernel. A tuple of two integers represents the height and width of the convolution kernel respectively.",
          "isRequired": true,
          "type": "Union[int, tuple[int]]"
        },
        "out_channels": {
          "def": "The channel number of the output tensor of the Conv2dTranspose layer.",
          "isRequired": true,
          "type": "int"
        },
        "output_padding": {
          "def": "The number of padding on the height and width directions of the output. The data type is an integer or a tuple of two integers. If output_padding is an integer, then the bottom and right padding are all equal to output_padding. If output_padding is a tuple of 2 integers, then the bottom and right padding is equal to output_padding[0], output_padding[1] respectively. If output_padding is not equal to 0, pad_mode must be pad. The value should be in range of [0, max(stride, dilation)) . Default: 0 .",
          "isRequired": false,
          "type": "Union[int, tuple[int]]"
        },
        "pad_mode": {
          "def": "Specifies the padding mode with a padding value of 0. It can be set to: \"same\" , \"valid\" or \"pad\" . Default: \"same\" .  \"same\": Pad the input around its edges so that the shape of input and output are the same when stride is set to 1. The amount of padding to is calculated by the operator internally, If the amount is even, it is uniformly distributed around the input, if it is odd, the excess amount goes to the right/bottom side. If this mode is set, padding must be 0. \"valid\": No padding is applied to the input, and the output returns the maximum possible height and width. Extra pixels that could not complete a full stride will be discarded. If this mode is set, padding must be 0. \"pad\": Pad the input with a specified amount. In this mode, the amount of padding in the height and width directions is determined by the padding parameter. If this mode is set, padding must be greater than or equal to 0.",
          "isRequired": false,
          "type": "str"
        },
        "padding": {
          "def": "The number of padding on the height and width directions of the input. The data type is an integer or a tuple of four integers. If padding is an integer, then the top, bottom, left, and right padding are all equal to padding. If padding is a tuple of 4 integers, then the top, bottom, left, and right padding is equal to padding[0], padding[1], padding[2], and padding[3] respectively. The value should be greater than or equal to 0. Default: 0 .",
          "isRequired": false,
          "type": "Union[int, tuple[int]]"
        },
        "stride": {
          "def": "The movement stride of the 2D convolution kernel. The data type is an integer or a tuple of two integers. An integer represents the movement step size in both height and width directions. A tuple of two integers represents the movement step size in the height and width directions respectively. Default: 1 .",
          "isRequired": false,
          "type": "Union[int, tuple[int]]"
        },
        "weight_init": {
          "def": "Initialization method of weight parameter. It can be a tensor, a string, an Initializer or a numbers.Number. When a string is specified, values from 'TruncatedNormal' , 'Normal' , 'Uniform' , 'HeUniform' and 'XavierUniform' distributions as well as constant 'One' and 'Zero' distributions are possible. Alias 'xavier_uniform' , 'he_uniform' , 'ones' and 'zeros' are acceptable. Uppercase and lowercase are both acceptable. Refer to the values of Initializer for more details. Default: None , weight will be initialized using HeUniform.",
          "isRequired": false,
          "type": "Union[tensor, str, Initializer, numbers.Number]"
        }
      },
      "mindspore.nn.Conv3dTranspose": {
        "bias_init": {
          "def": "Initialization method of bias parameter. Available initialization methods are the same as \u2018weight_init\u2019. Refer to the values of Initializer for more details. Default: None , bias will be initialized using Uniform.",
          "isRequired": false,
          "type": "Union[tensor, str, Initializer, numbers.Number]"
        },
        "data_format": {
          "def": "The optional value for data format. Currently only support 'NCDHW' . Default: 'NCDHW' .",
          "isRequired": false,
          "type": "str"
        },
        "dilation": {
          "def": "Dilation size of 3D convolution kernel. The data type is an integer or a tuple of three integers. If \\(k > 1\\), the kernel is sampled every k elements. The value of k on the depth, height and width directions is in range of [1, D], [1, H] and [1, W] respectively. Default: 1 .",
          "isRequired": false,
          "type": "Union[int, tuple[int]]"
        },
        "dtype": {
          "def": "Dtype of Parameters. Default: mstype.float32 .",
          "isRequired": false,
          "type": "mindspore.dtype"
        },
        "group": {
          "def": "Splits filter into groups, in_channels and out_channels must be divisible by group. Default: 1 .",
          "isRequired": false,
          "type": "int"
        },
        "has_bias": {
          "def": "Whether the Conv3dTranspose layer has a bias parameter. Default: False .",
          "isRequired": false,
          "type": "bool"
        },
        "in_channels": {
          "def": "The channel number of the input tensor of the Conv3dTranspose layer.",
          "isRequired": true,
          "type": "int"
        },
        "kernel_size": {
          "def": "Specifies the depth, height and width of the 3D convolution kernel. The data type is an integer or a tuple of three integers. An integer represents the depth, height and width of the convolution kernel. A tuple of three integers represents the depth, height and width of the convolution kernel respectively.",
          "isRequired": true,
          "type": "Union[int, tuple[int]]"
        },
        "out_channels": {
          "def": "The channel number of the output tensor of the Conv3dTranspose layer.",
          "isRequired": true,
          "type": "int"
        },
        "output_padding": {
          "def": "The number of padding on the depth, height and width directions of the output. The data type is an integer or a tuple of six integers. If output_padding is an integer, then the head, tail, top, bottom, left, and right padding are all equal to output_padding. If output_padding is a tuple of six integers, then the head, tail, top, bottom, left, and right padding is equal to output_padding[0], output_padding[1], output_padding[2], output_padding[3], output_padding[4] and output_padding[5] respectively. The value should be greater than or equal to 0. Default: 0 .",
          "isRequired": false,
          "type": "Union(int, tuple[int]"
        },
        "pad_mode": {
          "def": "Specifies the padding mode with a padding value of 0. It can be set to: \"same\" , \"valid\" or \"pad\" . Default: \"same\" .  \"same\": Pad the input around its depth/height/width dimension so that the shape of input and output are the same when stride is set to 1. The amount of padding to is calculated by the operator internally.  If the amount is even, it isuniformly distributed around the input, if it is odd, the excess amount goes to the front/right/bottom side. If this mode is set, padding must be 0. \"valid\": No padding is applied to the input, and the output returns the maximum possible depth, height and width. Extra pixels that could not complete a full stride will be discarded. If this mode is set, padding must be 0. \"pad\": Pad the input with a specified amount. In this mode, the amount of padding in the depth, height and width dimension is determined by the padding parameter. If this mode is set, padding must be greater than or equal to 0.",
          "isRequired": false,
          "type": "str"
        },
        "padding": {
          "def": "The number of padding on the depth, height and width directions of the input. The data type is an integer or a tuple of six integers. If padding is an integer, then the head, tail, top, bottom, left, and right padding are all equal to padding. If padding is a tuple of six integers, then the head, tail, top, bottom, left, and right padding is equal to padding[0], padding[1], padding[2], padding[3], padding[4] and padding[5] respectively. The value should be greater than or equal to 0. Default: 0 .",
          "isRequired": false,
          "type": "Union(int, tuple[int]"
        },
        "stride": {
          "def": "The movement stride of the 3D convolution kernel. The data type is an integer or a tuple of three integers. An integer represents the movement step size in depth, height and width directions. A tuple of three integers represents the movement step size in the depth, height and width directions respectively. Default: 1 .",
          "isRequired": false,
          "type": "Union[int, tuple[int]]"
        },
        "weight_init": {
          "def": "Initialization method of weight parameter. It can be a tensor, a string, an Initializer or a numbers.Number. When a string is specified, values from 'TruncatedNormal' , 'Normal' , 'Uniform' , 'HeUniform' and 'XavierUniform' distributions as well as constant 'One' and 'Zero' distributions are possible. Alias 'xavier_uniform' , 'he_uniform' , 'ones' and 'zeros' are acceptable. Uppercase and lowercase are both acceptable. Refer to the values of Initializer for more details. Default: None , weight will be initialized using HeUniform.",
          "isRequired": false,
          "type": "Union[tensor, str, Initializer, numbers.Number]"
        }
      }
    },
    "onnx": {
      "auto_pad": {
        "def": "auto_pad must be either NOTSET, SAME_UPPER, SAME_LOWER or VALID.Where default value is NOTSET, which means explicit padding is used.SAME_UPPER or SAME_LOWER mean pad the input so that output_shape[i] = input_shape[i] * strides[i] for each axis i",
        "type": "string"
      },
      "dilations": {
        "def": "dilation value along each spatial axis of the filter",
        "type": "ints"
      },
      "group": {
        "def": "number of groups input channels and output channels are dividedinto.",
        "type": "int"
      },
      "kernel_shape": {
        "def": "The shape of the convolution kernel",
        "type": "ints"
      },
      "output_padding": {
        "def": "Additional elements added to the side with higher coordinate indicesin the output",
        "type": "ints"
      },
      "output_shape": {
        "def": "The shape of the output can be explicitly set which will cause padsvalues to be auto generated",
        "type": "ints"
      },
      "pads": {
        "def": "Padding for the beginning and ending along each spatial axis, it cantake any value greater than or equal to 0",
        "type": "ints"
      },
      "strides": {
        "def": "Stride along each spatial axis",
        "type": "ints"
      }
    },
    "paddlepaddle": {
      "paddle.nn.Conv1DTranspose": {
        "bias": {
          "def": "Whether to use bias. Default: True.",
          "isRequired": true,
          "type": "bool"
        },
        "bias_attr": {
          "def": "The parameter attribute for the bias of conv1d_transpose. If it is set to False, no bias will be added to the output units. If it is set to None or one attribute of ParamAttr, conv1d_transpose will create ParamAttr as bias_attr. If the Initializer of the bias_attr is not set, the bias is initialized zero. Default: None.",
          "isRequired": false,
          "type": "ParamAttr|bool"
        },
        "dilation": {
          "def": "The dilation size. It means the spacing between the kernel points. If dilation is a tuple/list, it must contain one integer, (dilation_size). Default: dilation = 1.",
          "isRequired": false,
          "type": "int|tuple|list"
        },
        "groups": {
          "def": "The groups number of the Conv2D transpose layer. Inspired by grouped convolution in Alex Krizhevsky\u2019s Deep CNN paper, in which when group=2, the first half of the filters is only connected to the first half of the input channels, while the second half of the filters is only connected to the second half of the input channels. Default: groups = 1.",
          "isRequired": false,
          "type": "int"
        },
        "in_channels": {
          "def": "The number of channels in the input image.",
          "isRequired": true,
          "type": "int"
        },
        "kernel_size": {
          "def": "The filter size. If kernel_size is a tuple/list, it must contain one integers, (kernel_size). None if use output size to calculate kernel_size. Default: None. kernel_size and output_size should not be None at the same time.",
          "isRequired": true,
          "type": "int|tuple|list"
        },
        "out_channels": {
          "def": "The number of the filter. It is as same as the output feature map.",
          "isRequired": true,
          "type": "int"
        },
        "output_padding": {
          "def": "The count of zeros to be added to tail of each dimension. If it is a tuple/list, it must contain one integer. Default: 0.",
          "isRequired": false,
          "type": "int|list|tuple"
        },
        "padding": {
          "def": "The padding size. The padding argument effectively adds dilation * (kernel - 1) amount of zero-padding on both sides of input. If padding is a string, either \u2018VALID\u2019 or \u2018SAME\u2019 supported, which is the padding algorithm. If padding is a tuple or list, it could be in two forms: [pad] or [pad_left, pad_right]. Default: padding = 0.",
          "isRequired": false,
          "type": "int|list|str|tuple"
        },
        "stride": {
          "def": "The stride size. It means the stride in transposed convolution. If stride is a tuple/list, it must contain one integer, (stride_size). Default: stride = 1.",
          "isRequired": false,
          "type": "int|tuple|list"
        },
        "weight_attr": {
          "def": "The parameter attribute for learnable parameters/weights of conv1d_transpose. If it is set to None or one attribute of ParamAttr, conv1d_transpose will create ParamAttr as param_attr. If the Initializer of the param_attr is not set, the parameter is initialized with Xavier. Default: None.",
          "isRequired": false,
          "type": "ParamAttr"
        }
      },
      "paddle.nn.Conv2DTranspose": {
        "bias_attr": {
          "def": "The attribute for the bias of conv2d_transpose. If it is set to False, no bias will be added to the output units. If it is set to None or one attribute of ParamAttr, conv2d_transpose will create ParamAttr as bias_attr. If the Initializer of the bias_attr is not set, the bias is initialized zero. Default: None.",
          "isRequired": false,
          "type": "ParamAttr|bool"
        },
        "data_format": {
          "def": "Data format that specifies the layout of input. It can be \u201cNCHW\u201d or \u201cNHWC\u201d. Default: \u201cNCHW\u201d.",
          "isRequired": false,
          "type": "str"
        },
        "dilation": {
          "def": "The dilation size. If dilation is a list/tuple, it must contain two integers, (dilation_H, dilation_W). Otherwise, the dilation_H = dilation_W = dilation. Default: 1.",
          "isRequired": false,
          "type": "int|list|tuple"
        },
        "groups": {
          "def": "The groups number of the Conv2D transpose layer. Inspired by grouped convolution in Alex Krizhevsky\u2019s Deep CNN paper, in which when group=2, the first half of the filters is only connected to the first half of the input channels, while the second half of the filters is only connected to the second half of the input channels. Default: 1.",
          "isRequired": false,
          "type": "int"
        },
        "in_channels": {
          "def": "The number of channels in the input image.",
          "isRequired": true,
          "type": "int"
        },
        "kernel_size": {
          "def": "The kernel size. If kernel_size is a list/tuple, it must contain two integers, (kernel_size_H, kernel_size_W). Otherwise, the kernel will be a square.",
          "isRequired": true,
          "type": "int|list|tuple"
        },
        "out_channels": {
          "def": "The number of channels produced by the convolution.",
          "isRequired": true,
          "type": "int"
        },
        "output_padding": {
          "def": "Additional size added to one side of each dimension in the output shape. Default: 0.",
          "isRequired": false,
          "type": "int|list|tuple"
        },
        "padding": {
          "def": "The padding size. Padding coule be in one of the following forms. 1. a string in [\u2018valid\u2019, \u2018same\u2019]. 2. an int, which means each spartial dimension(depth, height, width) is zero paded by size of padding on both sides 3. a list[int] or tuple[int] whose length is the number of spartial dimensions, which contains the amount of padding on each side for each spartial dimension. It has the form [pad_d1, pad_d2, \u2026]. 4. a list[int] or tuple[int] whose length is 2 * number of spartial dimensions. It has the form [pad_before, pad_after, pad_before, pad_after, \u2026] for all spartial dimensions. 5. a list or tuple of pairs of ints. It has the form [[pad_before, pad_after], [pad_before, pad_after], \u2026]. Note that, the batch dimension and channel dimension are also included. Each pair of integers correspond to the amount of padding for a dimension of the input. Padding in batch dimension and channel dimension should be [0, 0] or (0, 0). The default value is 0.",
          "isRequired": false,
          "type": "int|str|tuple|list"
        },
        "stride": {
          "def": "The stride size. If stride is a list/tuple, it must contain two integers, (stride_H, stride_W). Otherwise, the stride_H = stride_W = stride. Default: 1.",
          "isRequired": false,
          "type": "int|list|tuple"
        },
        "weight_attr": {
          "def": "The parameter attribute for learnable weights(Parameter) of conv2d_transpose. If it is set to None or one attribute of ParamAttr, conv2d_transpose will create ParamAttr as param_attr. If the Initializer of the param_attr is not set, the parameter is initialized with Xavier. Default: None.",
          "isRequired": false,
          "type": "ParamAttr"
        }
      },
      "paddle.nn.Conv3DTranspose": {
        "bias_attr": {
          "def": "The parameter attribute for the bias of conv3d_transpose. If it is set to False, no bias will be added to the output units. If it is set to None or one attribute of ParamAttr, conv3d_transpose will create ParamAttr as bias_attr. If the Initializer of the bias_attr is not set, the bias is initialized zero. Default: None.",
          "isRequired": false,
          "type": "ParamAttr|bool"
        },
        "data_format": {
          "def": "Data format that specifies the layout of input. It can be \u201cNCDHW\u201d or \u201cNDHWC\u201d. Default: \u201cNCDHW\u201d.",
          "isRequired": false,
          "type": "str"
        },
        "dilation": {
          "def": "The dilation size. If dilation is a list/tuple, it must contain three integers, (dilation_D, dilation_H, dilation_W). Otherwise, the dilation_D = dilation_H = dilation_W = dilation. Default: 1.",
          "isRequired": false,
          "type": "int|list|tuple"
        },
        "groups": {
          "def": "The groups number of the Conv3D transpose layer. Inspired by grouped convolution in Alex Krizhevsky\u2019s Deep CNN paper, in which when groups = 2, the first half of the filters is only connected to the first half of the input channels, while the second half of the filters is only connected to the second half of the input channels. Default: 1.",
          "isRequired": false,
          "type": "int"
        },
        "in_channels": {
          "def": "The number of channels in the input image.",
          "isRequired": true,
          "type": "int"
        },
        "kernel_size": {
          "def": "The kernel size. If kernel_size is a list/tuple, it must contain three integers, (kernel_size_D, kernel_size_H, kernel_size_W). Otherwise, the kernel will be a square.",
          "isRequired": true,
          "type": "int|list|tuple"
        },
        "out_channels": {
          "def": "The number of channels produced by the convolution.",
          "isRequired": true,
          "type": "int"
        },
        "output_padding": {
          "def": "Additional size added to one side of each dimension in the output shape. Default: 0.",
          "isRequired": false,
          "type": "int|list|tuple"
        },
        "padding": {
          "def": "The padding size. Padding coule be in one of the following forms. 1. a string in [\u2018valid\u2019, \u2018same\u2019]. 2. an int, which means each spartial dimension(depth, height, width) is zero paded by size of padding 3. a list[int] or tuple[int] whose length is the number of spartial dimensions, which contains the amount of padding on each side for each spartial dimension. It has the form [pad_d1, pad_d2, \u2026]. 4. a list[int] or tuple[int] whose length is 2 * number of spartial dimensions. It has the form [pad_before, pad_after, pad_before, pad_after, \u2026] for all spartial dimensions. 5. a list or tuple of pairs of ints. It has the form [[pad_before, pad_after], [pad_before, pad_after], \u2026]. Note that, the batch dimension and channel dimension are also included. Each pair of integers correspond to the amount of padding for a dimension of the input. Padding in batch dimension and channel dimension should be [0, 0] or (0, 0). Default: 0.",
          "isRequired": false,
          "type": "int|str|tuple|list"
        },
        "stride": {
          "def": "The stride size. It means the stride in transposed convolution. If stride is a list/tuple, it must contain three integers, (stride_depth, stride_height, stride_width). Otherwise, stride_depth = stride_height = stride_width = stride. Default: 1.",
          "isRequired": false,
          "type": "int|list|tuple"
        },
        "weight_attr": {
          "def": "The parameter attribute for learnable parameters/weights of conv3d_transpose. If it is set to None or one attribute of ParamAttr, conv3d_transpose will create ParamAttr as param_attr. If the Initializer of the param_attr is not set, the parameter is initialized with Xavier. Default: None.",
          "isRequired": false,
          "type": "ParamAttr"
        }
      }
    },
    "pytorch": {
      "torch.nn.ConvTranspose1d": {
        "bias": {
          "def": "If True, adds a learnable bias to the output",
          "isRequired": false,
          "type": "bool"
        },
        "dilation": {
          "def": "Spacing between kernel elements",
          "isRequired": false,
          "type": "ints"
        },
        "groups": {
          "def": "Number of blocked connections from input channels to output channels",
          "isRequired": false,
          "type": "int"
        },
        "in_channels": {
          "def": "Number of channels in the input image",
          "isRequired": true,
          "type": "int"
        },
        "kernel_size": {
          "def": "Size of the convolving kernel",
          "isRequired": true,
          "type": "ints"
        },
        "out_channels": {
          "def": "Number of channels produced by the convolution",
          "isRequired": true,
          "type": "int"
        },
        "output_padding": {
          "def": "Additional size added to one side of the output shape",
          "isRequired": false,
          "type": "ints"
        },
        "padding": {
          "def": "dilation * (kernel_size - 1) - padding zero-padding will be added to both sides of the input",
          "isRequired": false,
          "type": "ints"
        },
        "stride": {
          "def": "Stride of the convolution",
          "isRequired": false,
          "type": "ints"
        }
      },
      "torch.nn.ConvTranspose2d": {
        "bias": {
          "def": "If True, adds a learnable bias to the output",
          "isRequired": false,
          "type": "bool"
        },
        "dilation": {
          "def": "Spacing between kernel elements",
          "isRequired": false,
          "type": "ints"
        },
        "groups": {
          "def": "Number of blocked connections from input channels to output channels",
          "isRequired": false,
          "type": "int"
        },
        "in_channels": {
          "def": "Number of channels in the input image",
          "isRequired": true,
          "type": "int"
        },
        "kernel_size": {
          "def": "Size of the convolving kernel",
          "isRequired": true,
          "type": "ints"
        },
        "out_channels": {
          "def": "Number of channels produced by the convolution",
          "isRequired": true,
          "type": "int"
        },
        "output_padding": {
          "def": "Additional size added to one side of each dimension in the output shape",
          "isRequired": false,
          "type": "ints"
        },
        "padding": {
          "def": "dilation * (kernel_size - 1) - padding zero-padding will be added to both sides of each dimension in the input",
          "isRequired": false,
          "type": "ints"
        },
        "stride": {
          "def": "Stride of the convolution",
          "isRequired": false,
          "type": "ints"
        }
      },
      "torch.nn.ConvTranspose3d": {
        "bias": {
          "def": "If True, adds a learnable bias to the output",
          "isRequired": false,
          "type": "bool"
        },
        "dilation": {
          "def": "Spacing between kernel elements",
          "isRequired": false,
          "type": "ints"
        },
        "groups": {
          "def": "Number of blocked connections from input channels to output channels",
          "isRequired": false,
          "type": "int"
        },
        "in_channels": {
          "def": "Number of channels in the input image",
          "isRequired": true,
          "type": "int"
        },
        "kernel_size": {
          "def": "Size of the convolving kernel",
          "isRequired": true,
          "type": "ints"
        },
        "out_channels": {
          "def": "Number of channels produced by the convolution",
          "isRequired": true,
          "type": "int"
        },
        "output_padding": {
          "def": "Additional size added to one side of each dimension in the output shape",
          "isRequired": false,
          "type": "ints"
        },
        "padding": {
          "def": "dilation * (kernel_size - 1) - padding zero-padding will be added to both sides of each dimension in the input",
          "isRequired": false,
          "type": "ints"
        },
        "stride": {
          "def": "Stride of the convolution",
          "isRequired": false,
          "type": "ints"
        }
      }
    },
    "tensorflow": {
      "tf.keras.layers.Conv1DTranspose": {
        "activation": {
          "def": "Activation function to use. If you don't specify anything, no activation is applied (see keras.activations).",
          "isRequired": false,
          "type": "string"
        },
        "activity_regularizer": {
          "def": "Regularizer function applied to the output of the layer (its \"activation\") (see keras.regularizers).",
          "isRequired": false,
          "type": "string"
        },
        "bias_constraint": {
          "def": "Constraint function applied to the bias vector (see keras.constraints).",
          "isRequired": false,
          "type": "string"
        },
        "bias_initializer": {
          "def": "Initializer for the bias vector (see keras.initializers). Defaults to 'zeros'.",
          "isRequired": false,
          "type": "string"
        },
        "bias_regularizer": {
          "def": "Regularizer function applied to the bias vector (see keras.regularizers).",
          "isRequired": false,
          "type": "string"
        },
        "data_format": {
          "def": "A string, one of channels_last (default) or channels_first. The ordering of the dimensions in the inputs. channels_last corresponds to inputs with shape (batch_size, length, channels) while channels_first corresponds to inputs with shape (batch_size, channels, length).",
          "isRequired": false,
          "type": "string"
        },
        "dilation_rate": {
          "def": "an integer, specifying the dilation rate to use for dilated convolution. Currently, specifying a dilation_rate value != 1 is incompatible with specifying a stride value != 1. Also dilation rate larger than 1 is not currently supported.",
          "isRequired": false,
          "type": "int"
        },
        "filters": {
          "def": "Integer, the dimensionality of the output space (i.e. the number of output filters in the convolution).",
          "isRequired": true,
          "type": "int"
        },
        "kernel_constraint": {
          "def": "Constraint function applied to the kernel matrix (see keras.constraints).",
          "isRequired": false,
          "type": "string"
        },
        "kernel_initializer": {
          "def": "Initializer for the kernel weights matrix (see keras.initializers). Defaults to 'glorot_uniform'.",
          "isRequired": false,
          "type": "string"
        },
        "kernel_regularizer": {
          "def": "Regularizer function applied to the kernel weights matrix (see keras.regularizers).",
          "isRequired": false,
          "type": "string"
        },
        "kernel_size": {
          "def": "An integer length of the 1D convolution window.",
          "isRequired": true,
          "type": "int"
        },
        "output_padding": {
          "def": "An integer specifying the amount of padding along the time dimension of the output tensor. The amount of output padding must be lower than the stride. If set to None (default), the output shape is inferred.",
          "isRequired": false,
          "type": "int"
        },
        "padding": {
          "def": "one of \"valid\" or \"same\" (case-insensitive). \"valid\" means no padding. \"same\" results in padding with zeros evenly to the left/right or up/down of the input such that output has the same height/width dimension as the input.",
          "isRequired": false,
          "type": "string"
        },
        "strides": {
          "def": "An integer specifying the stride of the convolution along the time dimension. Specifying a stride value != 1 is incompatible with specifying a dilation_rate value != 1. Defaults to 1.",
          "isRequired": false,
          "type": "int"
        },
        "use_bias": {
          "def": "Boolean, whether the layer uses a bias vector.",
          "isRequired": false,
          "type": "bool"
        }
      },
      "tf.keras.layers.Conv2DTranspose": {
        "activation": {
          "def": "Activation function to use. If you don't specify anything, no activation is applied (see keras.activations).",
          "isRequired": false,
          "type": "string"
        },
        "activity_regularizer": {
          "def": "Regularizer function applied to the output of the layer (its \"activation\") (see keras.regularizers).",
          "isRequired": false,
          "type": "string"
        },
        "bias_constraint": {
          "def": "Constraint function applied to the bias vector (see keras.constraints).",
          "isRequired": false,
          "type": "string"
        },
        "bias_initializer": {
          "def": "Initializer for the bias vector (see keras.initializers). Defaults to 'zeros'.",
          "isRequired": false,
          "type": "string"
        },
        "bias_regularizer": {
          "def": "Regularizer function applied to the bias vector (see keras.regularizers).",
          "isRequired": false,
          "type": "string"
        },
        "data_format": {
          "def": "A string, one of channels_last (default) or channels_first. The ordering of the dimensions in the inputs. channels_last corresponds to inputs with shape (batch_size, height, width, channels) while channels_first corresponds to inputs with shape (batch_size, channels, height, width). When unspecified, uses image_data_format value found in your Keras config file at ~/.keras/keras.json (if exists) else 'channels_last'. Defaults to \"channels_last\".",
          "isRequired": false,
          "type": "string"
        },
        "dilation_rate": {
          "def": "an integer, specifying the dilation rate for all spatial dimensions for dilated convolution. Specifying different dilation rates for different dimensions is not supported. Currently, specifying any dilation_rate value != 1 is incompatible with specifying any stride value != 1.",
          "isRequired": false,
          "type": "int"
        },
        "filters": {
          "def": "Integer, the dimensionality of the output space (i.e. the number of output filters in the convolution).",
          "isRequired": true,
          "type": "int"
        },
        "kernel_constraint": {
          "def": "Constraint function applied to the kernel matrix (see keras.constraints).",
          "isRequired": false,
          "type": "string"
        },
        "kernel_initializer": {
          "def": "Initializer for the kernel weights matrix (see keras.initializers). Defaults to 'glorot_uniform'.",
          "isRequired": false,
          "type": "string"
        },
        "kernel_regularizer": {
          "def": "Regularizer function applied to the kernel weights matrix (see keras.regularizers).",
          "isRequired": false,
          "type": "string"
        },
        "kernel_size": {
          "def": "An integer or tuple/list of 2 integers, specifying the height and width of the 2D convolution window. Can be a single integer to specify the same value for all spatial dimensions.",
          "isRequired": true,
          "type": "int"
        },
        "output_padding": {
          "def": "An integer or tuple/list of 2 integers, specifying the amount of padding along the height and width of the output tensor. Can be a single integer to specify the same value for all spatial dimensions. The amount of output padding along a given dimension must be lower than the stride along that same dimension. If set to None (default), the output shape is inferred.",
          "isRequired": false,
          "type": "int"
        },
        "padding": {
          "def": "one of \"valid\" or \"same\" (case-insensitive). \"valid\" means no padding. \"same\" results in padding with zeros evenly to the left/right or up/down of the input such that output has the same height/width dimension as the input.",
          "isRequired": false,
          "type": "string"
        },
        "strides": {
          "def": "An integer or tuple/list of 2 integers, specifying the strides of the convolution along the height and width. Can be a single integer to specify the same value for all spatial dimensions. Specifying any stride value != 1 is incompatible with specifying any dilation_rate value != 1.",
          "isRequired": false,
          "type": "int"
        },
        "use_bias": {
          "def": "Boolean, whether the layer uses a bias vector.",
          "isRequired": false,
          "type": "bool"
        }
      },
      "tf.keras.layers.Conv3DTranspose": {
        "activation": {
          "def": "Activation function to use. If you don't specify anything, no activation is applied (see keras.activations).",
          "isRequired": false,
          "type": "string"
        },
        "activity_regularizer": {
          "def": "Regularizer function applied to the output of the layer (its \"activation\") (see keras.regularizers).",
          "isRequired": false,
          "type": "string"
        },
        "bias_constraint": {
          "def": "Constraint function applied to the bias vector (see keras.constraints).",
          "isRequired": false,
          "type": "string"
        },
        "bias_initializer": {
          "def": "Initializer for the bias vector (see keras.initializers). Defaults to 'zeros'.",
          "isRequired": false,
          "type": "string"
        },
        "bias_regularizer": {
          "def": "Regularizer function applied to the bias vector (see keras.regularizers).",
          "isRequired": false,
          "type": "string"
        },
        "data_format": {
          "def": "A string, one of channels_last (default) or channels_first. The ordering of the dimensions in the inputs. channels_last corresponds to inputs with shape (batch_size, depth, height, width, channels) while channels_first corresponds to inputs with shape (batch_size, channels, depth, height, width). When unspecified, uses image_data_format value found in your Keras config file at ~/.keras/keras.json (if exists) else 'channels_last'. Defaults to 'channels_last'.",
          "isRequired": false,
          "type": "string"
        },
        "dilation_rate": {
          "def": "an integer or tuple/list of 3 integers, specifying the dilation rate to use for dilated convolution. Can be a single integer to specify the same value for all spatial dimensions. Currently, specifying any dilation_rate value != 1 is incompatible with specifying any stride value != 1.",
          "isRequired": false,
          "type": "int"
        },
        "filters": {
          "def": "Integer, the dimensionality of the output space (i.e. the number of output filters in the convolution).",
          "isRequired": true,
          "type": "int"
        },
        "kernel_constraint": {
          "def": "Constraint function applied to the kernel matrix (see keras.constraints).",
          "isRequired": false,
          "type": "string"
        },
        "kernel_initializer": {
          "def": "Initializer for the kernel weights matrix (see keras.initializers). Defaults to 'glorot_uniform'.",
          "isRequired": false,
          "type": "string"
        },
        "kernel_regularizer": {
          "def": "Regularizer function applied to the kernel weights matrix (see keras.regularizers).",
          "isRequired": false,
          "type": "string"
        },
        "kernel_size": {
          "def": "An integer or tuple/list of 3 integers, specifying the depth, height and width of the 3D convolution window. Can be a single integer to specify the same value for all spatial dimensions.",
          "isRequired": true,
          "type": "int"
        },
        "output_padding": {
          "def": "An integer or tuple/list of 3 integers, specifying the amount of padding along the depth, height, and width. Can be a single integer to specify the same value for all spatial dimensions. The amount of output padding along a given dimension must be lower than the stride along that same dimension. If set to None (default), the output shape is inferred.",
          "isRequired": false,
          "type": "int"
        },
        "padding": {
          "def": "one of \"valid\" or \"same\" (case-insensitive). \"valid\" means no padding. \"same\" results in padding with zeros evenly to the left/right or up/down of the input such that output has the same height/width dimension as the input.",
          "isRequired": false,
          "type": "string"
        },
        "strides": {
          "def": "An integer or tuple/list of 3 integers, specifying the strides of the convolution along the depth, height  and width. Can be a single integer to specify the same value for all spatial dimensions. Specifying any stride value != 1 is incompatible with specifying any dilation_rate value != 1.",
          "isRequired": false,
          "type": "int"
        },
        "use_bias": {
          "def": "Boolean, whether the layer uses a bias vector.",
          "isRequired": false,
          "type": "bool"
        }
      }
    }
  },
  "Dropout": {
    "mindspore": {
      "mindspore.nn.Dropout1d": {
        "p": {
          "def": "The dropping probability of a channel, between 0 and 1, e.g. p = 0.8, which means an 80% chance of being set to 0. Default: 0.5 .",
          "isRequired": false,
          "type": "float"
        }
      },
      "mindspore.nn.Dropout2d": {
        "p": {
          "def": "",
          "isRequired": false,
          "type": "float"
        }
      },
      "mindspore.nn.Dropout3d": {
        "p": {
          "def": "",
          "isRequired": false,
          "type": "float"
        }
      },
      "mindspore.ops.dropout": {
        "input": {
          "def": "The input tensor of shape \\((*, N)\\), with data type of float16, float32 or float64.",
          "isRequired": true,
          "type": "tensor"
        },
        "p": {
          "def": "The dropping rate, between 0 and 1, e.g. p = 0.1, means dropping out 10% of input units. Default: 0.5 .",
          "isRequired": false,
          "type": "float"
        },
        "seed": {
          "def": "Seed is used as entropy source for Random number engines generating pseudo-random numbers. Default: None , which will be treated as 0 .",
          "isRequired": false,
          "type": "int"
        },
        "training": {
          "def": "Apply dropout if is True. Default: True.",
          "isRequired": false,
          "type": "bool"
        }
      }
    },
    "onnx": {
      "seed": {
        "def": "(Optional) Seed to the random generator, if not specified we willauto generate one.",
        "type": "int"
      }
    },
    "paddlepaddle": {
      "paddle.nn.Dropout": {
        "axis": {
          "def": "The axis along which the dropout is performed. Default: None.",
          "isRequired": false,
          "type": "int|list|tuple"
        },
        "mode": {
          "def": "",
          "isRequired": false,
          "type": "str"
        },
        "name": {
          "def": "Name for the operation, Default: None. For more information, please refer to Name.",
          "isRequired": false,
          "type": "str"
        },
        "p": {
          "def": "Probability of setting units to zero. Default: 0.5",
          "isRequired": false,
          "type": "float|int"
        }
      },
      "paddle.nn.Dropout2D": {
        "data_format": {
          "def": "Specify the data format of the input, and the data format of the output will be consistent with that of the input. An optional string from NCHW or NHWC. When it is NCHW, the data is stored in the order of: [batch_size, input_channels, input_height, input_width]. Default: NCHW.",
          "isRequired": false,
          "type": "str"
        },
        "name": {
          "def": "Name for the operation, Default: None. For more information, please refer to Name.",
          "isRequired": false,
          "type": "str"
        },
        "p": {
          "def": "Probability of setting units to zero. Default: 0.5.",
          "isRequired": false,
          "type": "float"
        }
      },
      "paddle.nn.Dropout3D": {
        "data_format": {
          "def": "Specify the data format of the input, and the data format of the output will be consistent with that of the input. An optional string from NCDHW or NDHWC. When it is NCDHW, the data is stored in the order of: [batch_size, input_channels, input_depth, input_height, input_width]. Default: NCDHW.",
          "isRequired": false,
          "type": "str"
        },
        "name": {
          "def": "Name for the operation, Default: None. For more information, please refer to Name.",
          "isRequired": false,
          "type": "str"
        },
        "p": {
          "def": "Probability of setting units to zero. Default: 0.5.",
          "isRequired": false,
          "type": "float | int"
        }
      }
    },
    "pytorch": {
      "torch.nn.Dropout": {
        "inplace": {
          "def": "If set to True, will do this operation in-place",
          "isRequired": false,
          "type": "bool"
        },
        "p": {
          "def": "probability of an element to be zeroed",
          "isRequired": false,
          "type": "float"
        }
      },
      "torch.nn.Dropout1d": {
        "inplace": {
          "def": "If set to True, will do this operation in-place",
          "isRequired": false,
          "type": "bool"
        },
        "p": {
          "def": "probability of an element to be zero-ed.",
          "isRequired": false,
          "type": "float"
        }
      },
      "torch.nn.Dropout2d": {
        "inplace": {
          "def": "If set to True, will do this operation in-place",
          "isRequired": false,
          "type": "bool"
        },
        "p": {
          "def": "probability of an element to be zero-ed.",
          "isRequired": false,
          "type": "float"
        }
      },
      "torch.nn.Dropout3d": {
        "inplace": {
          "def": "If set to True, will do this operation in-place",
          "isRequired": false,
          "type": "bool"
        },
        "p": {
          "def": "probability of an element to be zeroed.",
          "isRequired": false,
          "type": "float"
        }
      },
      "torch.nn.functional.dropout": {
        "inplace": {
          "def": "If set to True, will do this operation in-place",
          "isRequired": false,
          "type": "bool"
        },
        "p": {
          "def": "probability of an element to be zeroed",
          "isRequired": false,
          "type": "float"
        },
        "training": {
          "def": "apply dropout if is True",
          "isRequired": false,
          "type": "bool"
        }
      }
    },
    "tensorflow": {
      "tf.keras.layers.Dropout": {
        "noise_shape": {
          "def": "1D integer tensor representing the shape of the binary dropout mask that will be multiplied with the input. For instance, if your inputs have shape (batch_size, timesteps, features) and you want the dropout mask to be the same for all timesteps, you can use noise_shape=(batch_size, 1, features).",
          "isRequired": false,
          "type": "int"
        },
        "rate": {
          "def": "Float between 0 and 1. Fraction of the input units to drop.",
          "isRequired": true,
          "type": "float"
        },
        "seed": {
          "def": "A Python integer to use as random seed.",
          "isRequired": false,
          "type": "int"
        }
      }
    }
  },
  "Elu": {
    "mindspore": {
      "mindspore.nn.ELU": {
        "alpha": {
          "def": "The alpha value of ELU, the data type is float. Default: 1.0 .",
          "isRequired": false,
          "type": "float"
        }
      }
    },
    "onnx": {
      "alpha": {
        "def": "Coefficient of ELU.",
        "type": "float"
      }
    },
    "paddlepaddle": {
      "paddle.nn.ELU": {
        "alpha": {
          "def": "The \u2018alpha\u2019 value of the ELU formulation. Default is 1.0.",
          "isRequired": false,
          "type": "float"
        },
        "name": {
          "def": "Name for the operation (optional, default is None). For more information, please refer to Name.",
          "isRequired": false,
          "type": "str"
        }
      }
    },
    "pytorch": {
      "torch.nn.ELU": {
        "alpha": {
          "def": "the \u03b1\\alpha\u03b1 value for the ELU formulation",
          "isRequired": false,
          "type": "float"
        },
        "inplace": {
          "def": "can optionally do the operation in-place",
          "isRequired": false,
          "type": "bool"
        }
      }
    },
    "tensorflow": {
      "tf.keras.activations.elu": {
        "alpha": {
          "def": "A scalar, slope of negative section. alpha controls the value to which an ELU saturates for negative net inputs.",
          "isRequired": false,
          "type": "float"
        },
        "x": {
          "def": "Input tensor.",
          "isRequired": true,
          "type": "tensor"
        }
      },
      "tf.keras.layers.ELU": {
        "alpha": {
          "def": "Scale for the negative factor.",
          "isRequired": false,
          "type": "float"
        }
      },
      "tf.nn.elu": {
        "features": {
          "def": "A tensor. Must be one of the following types: half, bfloat16, float32, float64.",
          "isRequired": true,
          "type": "tensor"
        },
        "name": {
          "def": "A name for the operation (optional).",
          "isRequired": false,
          "type": "string"
        }
      }
    }
  },
  "Erf": {
    "mindspore": {
      "mindspore.ops.erf": {
        "input": {
          "def": "The input tensor of Gaussian error function.",
          "isRequired": true,
          "type": "tensor"
        }
      }
    },
    "onnx": {},
    "paddlepaddle": {
      "paddle.erf": {
        "name": {
          "def": "Name for the operation (optional, default is None). For more information, please refer to Name.",
          "isRequired": false,
          "type": "str"
        },
        "x": {
          "def": "The input tensor, it\u2019s data type should be float32, float64.",
          "isRequired": true,
          "type": "tensor"
        }
      }
    },
    "pytorch": {
      "torch.erf": {
        "input": {
          "def": "the input tensor.",
          "isRequired": true,
          "type": "tensor"
        }
      }
    },
    "tensorflow": {
      "tf.math.erf": {
        "name": {
          "def": "A name for the operation (optional).",
          "isRequired": false,
          "type": "string"
        },
        "x": {
          "def": "A tensor. Must be one of the following types: bfloat16, half, float32, float64.",
          "isRequired": true,
          "type": "tensor"
        }
      }
    }
  },
  "Flatten": {
    "mindspore": {
      "mindspore.nn.Flatten": {
        "end_dim": {
          "def": "The last dimension to flatten. Default: -1 .",
          "isRequired": false,
          "type": "int"
        },
        "start_dim": {
          "def": "The first dimension to flatten. Default: 1 .",
          "isRequired": false,
          "type": "int"
        }
      }
    },
    "onnx": {
      "axis": {
        "def": "Indicate up to which input dimensions (exclusive) should beflattened to the outer dimension of the output",
        "type": "int"
      }
    },
    "paddlepaddle": {
      "paddle.nn.Flatten": {
        "start_axis": {
          "def": "first dim to flatten (default = 1)",
          "isRequired": false,
          "type": "int"
        },
        "stop_axis": {
          "def": "last dim to flatten (default = -1).",
          "isRequired": false,
          "type": "int"
        }
      }
    },
    "pytorch": {
      "torch.nn.Flatten": {
        "end_dim": {
          "def": "last dim to flatten (default = -1).",
          "isRequired": false,
          "type": "int"
        },
        "start_dim": {
          "def": "first dim to flatten (default = 1).",
          "isRequired": false,
          "type": "int"
        }
      }
    },
    "tensorflow": {
      "tf.keras.layers.Flatten": {
        "data_format": {
          "def": "A string, one of channels_last (default) or channels_first. The ordering of the dimensions in the inputs. channels_last corresponds to inputs with shape (batch, ..., channels) while channels_first corresponds to inputs with shape (batch, channels, ...). When unspecified, uses image_data_format value found in your Keras config file at ~/.keras/keras.json (if exists) else 'channels_last'. Defaults to 'channels_last'.",
          "isRequired": false,
          "type": "string"
        }
      }
    }
  },
  "Floor": {
    "mindspore": {
      "mindspore.ops.floor": {
        "input": {
          "def": "The input tensor, its data type must be float16, float32 or float64.",
          "isRequired": true,
          "type": "tensor"
        }
      }
    },
    "onnx": {
      "consumed_inputs": {
        "def": "legacy optimization attribute.",
        "type": "ints"
      }
    },
    "paddlepaddle": {
      "paddle.floor": {
        "name": {
          "def": "Name for the operation (optional, default is None). For more information, please refer to Name.",
          "isRequired": false,
          "type": "str"
        },
        "x": {
          "def": "Input of Floor operator, an N-D tensor, with data type float32, float64 or float16.",
          "isRequired": true,
          "type": "tensor"
        }
      }
    },
    "pytorch": {
      "torch.floor": {
        "input": {
          "def": "the input tensor.",
          "isRequired": true,
          "type": "tensor"
        }
      }
    },
    "tensorflow": {
      "tf.math.floor": {
        "name": {
          "def": "A name for the operation (optional).",
          "isRequired": false,
          "type": "string"
        },
        "x": {
          "def": "A tensor. Must be one of the following types: bfloat16, half, float32, float64.",
          "isRequired": true,
          "type": "tensor"
        }
      }
    }
  },
  "Gelu": {
    "mindspore": {
      "mindspore.nn.GELU": {
        "approximate": {
          "def": "Whether to enable approximation. Default: True .",
          "isRequired": false,
          "type": "bool"
        }
      }
    },
    "onnx": {
      "approximate": {
        "def": "Gelu approximation algorithm: \"tanh\", \"none\"(default).\"none\":do not use approximation.\"tanh\": use tanh approximation.",
        "type": "string"
      }
    },
    "paddlepaddle": {
      "paddle.nn.GELU": {
        "approximate": {
          "def": "Wether to enable approximation. Default is False.",
          "isRequired": false,
          "type": "bool"
        },
        "name": {
          "def": "Name for the operation (optional, default is None). For more information, please refer to Name.",
          "isRequired": false,
          "type": "str"
        }
      }
    },
    "pytorch": {
      "torch.nn.GELU": {
        "approximate": {
          "def": "the gelu approximation algorithm to use: 'none' | 'tanh'",
          "isRequired": false,
          "type": "string"
        }
      }
    },
    "tensorflow": {
      "tf.keras.activations.gelu": {
        "approximate": {
          "def": "A bool, whether to enable approximation.",
          "isRequired": false,
          "type": "bool"
        },
        "x": {
          "def": "Input tensor.",
          "isRequired": true,
          "type": "tensor"
        }
      },
      "tf.nn.gelu": {
        "approximate": {
          "def": "An optional bool. Defaults to False. Whether to enable approximation.",
          "isRequired": false,
          "type": "bool"
        },
        "features": {
          "def": "A float tensor representing preactivation values.",
          "isRequired": true,
          "type": "tensor"
        },
        "name": {
          "def": "A name for the operation (optional).",
          "isRequired": false,
          "type": "string"
        }
      }
    }
  },
  "Gemm": {
    "mindspore": {},
    "onnx": {
      "alpha": {
        "def": "Scalar multiplier for the product of input tensors A * B.",
        "type": "float"
      },
      "beta": {
        "def": "Scalar multiplier for input tensor C.",
        "type": "float"
      },
      "transA": {
        "def": "Whether A should be transposed",
        "type": "int"
      },
      "transB": {
        "def": "Whether B should be transposed",
        "type": "int"
      }
    },
    "paddlepaddle": {},
    "pytorch": {
      "torch.nn.Linear": {
        "bias": {
          "def": "If set to False, the layer will not learn an additive bias",
          "isRequired": false,
          "type": "bool"
        },
        "in_features": {
          "def": " size of each input sample",
          "isRequired": true,
          "type": "int"
        },
        "out_features": {
          "def": "size of each output sample",
          "isRequired": true,
          "type": "int"
        }
      }
    },
    "tensorflow": {}
  },
  "GlobalAveragePool": {
    "mindspore": {},
    "onnx": {},
    "paddlepaddle": {},
    "pytorch": {},
    "tensorflow": {
      "tf.keras.layers.GlobalAveragePooling1D": {
        "data_format": {
          "def": "A string, one of channels_last (default) or channels_first. The ordering of the dimensions in the inputs. channels_last corresponds to inputs with shape (batch, steps, features) while channels_first corresponds to inputs with shape (batch, features, steps).",
          "isRequired": false,
          "type": "string"
        }
      },
      "tf.keras.layers.GlobalAveragePooling2D": {
        "data_format": {
          "def": "A string, one of channels_last (default) or channels_first. The ordering of the dimensions in the inputs. channels_last corresponds to inputs with shape (batch, height, width, channels) while channels_first corresponds to inputs with shape (batch, channels, height, width). When unspecified, uses image_data_format value found in your Keras config file at ~/.keras/keras.json (if exists) else 'channels_last'. Defaults to 'channels_last'.",
          "isRequired": false,
          "type": "string"
        }
      },
      "tf.keras.layers.GlobalAveragePooling3D": {
        "data_format": {
          "def": "A string, one of channels_last (default) or channels_first. The ordering of the dimensions in the inputs. channels_last corresponds to inputs with shape (batch, spatial_dim1, spatial_dim2, spatial_dim3, channels) while channels_first corresponds to inputs with shape (batch, channels, spatial_dim1, spatial_dim2, spatial_dim3). When unspecified, uses image_data_format value found in your Keras config file at ~/.keras/keras.json (if exists) else 'channels_last'. Defaults to 'channels_last'.",
          "isRequired": false,
          "type": "string"
        }
      }
    }
  },
  "GlobalMaxPool": {
    "mindspore": {},
    "onnx": {},
    "paddlepaddle": {},
    "pytorch": {},
    "tensorflow": {
      "tf.keras.layers.GlobalMaxPooling1D": {
        "data_format": {
          "def": "A string, one of channels_last (default) or channels_first. The ordering of the dimensions in the inputs. channels_last corresponds to inputs with shape (batch, steps, features) while channels_first corresponds to inputs with shape (batch, features, steps).",
          "isRequired": false,
          "type": "string"
        }
      },
      "tf.keras.layers.GlobalMaxPooling2D": {
        "data_format": {
          "def": "A string, one of channels_last (default) or channels_first. The ordering of the dimensions in the inputs. channels_last corresponds to inputs with shape (batch, height, width, channels) while channels_first corresponds to inputs with shape (batch, channels, height, width). When unspecified, uses image_data_format value found in your Keras config file at ~/.keras/keras.json (if exists) else 'channels_last'. Defaults to 'channels_last'.",
          "isRequired": false,
          "type": "string"
        }
      },
      "tf.keras.layers.GlobalMaxPooling3D": {
        "data_format": {
          "def": "A string, one of channels_last (default) or channels_first. The ordering of the dimensions in the inputs. channels_last corresponds to inputs with shape (batch, spatial_dim1, spatial_dim2, spatial_dim3, channels) while channels_first corresponds to inputs with shape (batch, channels, spatial_dim1, spatial_dim2, spatial_dim3). When unspecified, uses image_data_format value found in your Keras config file at ~/.keras/keras.json (if exists) else 'channels_last'. Defaults to 'channels_last'.",
          "isRequired": false,
          "type": "string"
        }
      }
    }
  },
  "HardSigmoid": {
    "mindspore": {
      "mindspore.nn.HSigmoid": {
        "input_x": {
          "def": "input_x (tensor) - The input of HSigmoid. tensor of any dimension.",
          "isRequired": true,
          "type": "tensor"
        }
      }
    },
    "onnx": {
      "alpha": {
        "def": "Value of alpha.",
        "type": "float"
      },
      "beta": {
        "def": "Value of beta.",
        "type": "float"
      }
    },
    "paddlepaddle": {
      "paddle.nn.Hardsigmoid": {
        "name": {
          "def": "Name for the operation (optional, default is None). For more information, please refer to Name.",
          "isRequired": false,
          "type": "str"
        }
      }
    },
    "pytorch": {
      "torch.nn.Hardsigmoid": {
        "inplace": {
          "def": "can optionally do the operation in-place",
          "isRequired": false,
          "type": "bool"
        }
      }
    },
    "tensorflow": {}
  },
  "HardSwish": {
    "mindspore": {
      "mindspore.nn.HSwish": {
        "x": {
          "def": "x (tensor) - The input of HSwish, data type must be float16 or float32. The shape is \\((N,*)\\) where \\(*\\) means, any number of additional dimensions.",
          "isRequired": true,
          "type": "tensor"
        }
      }
    },
    "onnx": {},
    "paddlepaddle": {
      "paddle.nn.Hardswish": {
        "name": {
          "def": "Name for the operation (optional, default is None). For more information, please refer to Name.",
          "isRequired": false,
          "type": "str"
        }
      }
    },
    "pytorch": {
      "torch.nn.Hardswish": {
        "inplace": {
          "def": "can optionally do the operation in-place",
          "isRequired": false,
          "type": "bool"
        }
      }
    },
    "tensorflow": {}
  },
  "InstanceNormalization": {
    "mindspore": {
      "mindspore.nn.InstanceNorm1d": {
        "affine": {
          "def": "A bool value. When set to True, gamma and beta can be learned. Default: True .",
          "isRequired": false,
          "type": "bool"
        },
        "beta_init": {
          "def": "Initializer for the beta weight. The values of str refer to the function initializer including 'zeros' , 'ones' , etc. When initialized with tensor, the shape should be \\((C)\\). Default: 'zeros' .",
          "isRequired": false,
          "type": "Union[tensor, str, Initializer, numbers.Number]"
        },
        "dtype": {
          "def": "Dtype of Parameters. Default: mstype.float32 .",
          "isRequired": false,
          "type": "mindspore.dtype"
        },
        "eps": {
          "def": "A value added to the denominator for numerical stability. Default: 1e-5 .",
          "isRequired": false,
          "type": "float"
        },
        "gamma_init": {
          "def": "Initializer for the gamma weight. The values of str refer to the function initializer including 'zeros' , 'ones' , etc. When initialized with tensor, the shape should be \\((C)\\). Default: 'ones' .",
          "isRequired": false,
          "type": "Union[tensor, str, Initializer, numbers.Number]"
        },
        "momentum": {
          "def": "A floating hyperparameter of the momentum for the running_mean and running_var computation. Default: 0.1 .",
          "isRequired": false,
          "type": "float"
        },
        "num_features": {
          "def": "C from an expected input of size \\((N, C, L)\\).",
          "isRequired": true,
          "type": "int"
        }
      },
      "mindspore.nn.InstanceNorm2d": {
        "affine": {
          "def": "A bool value. When set to True , gamma and beta can be learned. Default: True .",
          "isRequired": false,
          "type": "bool"
        },
        "beta_init": {
          "def": "Initializer for the beta weight. The values of str refer to the function initializer including 'zeros' , 'ones' , etc. When initialized with tensor, the shape should be \\((C)\\). Default: 'zeros' .",
          "isRequired": false,
          "type": "Union[tensor, str, Initializer, numbers.Number]"
        },
        "dtype": {
          "def": "Dtype of Parameters. Default: mstype.float32 .",
          "isRequired": false,
          "type": "mindspore.dtype"
        },
        "eps": {
          "def": "A value added to the denominator for numerical stability. Default: 1e-5 .",
          "isRequired": false,
          "type": "float"
        },
        "gamma_init": {
          "def": "Initializer for the gamma weight. The values of str refer to the function initializer including 'zeros' , 'ones' , etc. When initialized with tensor, the shape should be \\((C)\\). Default: 'ones' .",
          "isRequired": false,
          "type": "Union[tensor, str, Initializer, numbers.Number]"
        },
        "momentum": {
          "def": "A floating hyperparameter of the momentum for the running_mean and running_var computation. Default: 0.1 .",
          "isRequired": false,
          "type": "float"
        },
        "num_features": {
          "def": "C from an expected input of size \\((N, C, H, W)\\).",
          "isRequired": true,
          "type": "int"
        }
      },
      "mindspore.nn.InstanceNorm3d": {
        "affine": {
          "def": "A bool value. When set to True , gamma and beta can be learned. Default: True .",
          "isRequired": false,
          "type": "bool"
        },
        "beta_init": {
          "def": "Initializer for the beta weight. The values of str refer to the function initializer including 'zeros' , 'ones' , etc. When initialized with tensor, the shape should be \\((C)\\). Default: 'zeros' .",
          "isRequired": false,
          "type": "Union[tensor, str, Initializer, numbers.Number]"
        },
        "dtype": {
          "def": "Dtype of Parameters. Default: mstype.float32 .",
          "isRequired": false,
          "type": "mindspore.dtype"
        },
        "eps": {
          "def": "A value added to the denominator for numerical stability. Default: 1e-5 .",
          "isRequired": false,
          "type": "float"
        },
        "gamma_init": {
          "def": "Initializer for the gamma weight. The values of str refer to the function initializer including 'zeros' , 'ones' , etc. When initialized with tensor, the shape should be \\((C)\\). Default: 'ones' .",
          "isRequired": false,
          "type": "Union[tensor, str, Initializer, numbers.Number]"
        },
        "momentum": {
          "def": "A floating hyperparameter of the momentum for the running_mean and running_var computation. Default: 0.1 .",
          "isRequired": false,
          "type": "float"
        },
        "num_features": {
          "def": "C from an expected input of size \\((N, C, D, H, W)\\).",
          "isRequired": true,
          "type": "int"
        }
      }
    },
    "onnx": {
      "epsilon": {
        "def": "The epsilon value to use to avoid division by zero.",
        "type": "float"
      }
    },
    "paddlepaddle": {},
    "pytorch": {
      "torch.nn.InstanceNorm1d": {
        "affine": {
          "def": "a boolean value that when set to True, this module has learnable affine parameters, initialized the same way as done for batch normalization",
          "isRequired": false,
          "type": "bool"
        },
        "eps": {
          "def": "a value added to the denominator for numerical stability",
          "isRequired": false,
          "type": "float"
        },
        "momentum": {
          "def": "the value used for the running_mean and running_var computation",
          "isRequired": false,
          "type": "float"
        },
        "num_features": {
          "def": "number of features or channels CCC of the input",
          "isRequired": true,
          "type": "int"
        },
        "track_running_stats": {
          "def": "a boolean value that when set to True, this module tracks the running mean and variance, and when set to False, this module does not track such statistics and always uses batch statistics in both training and eval modes",
          "isRequired": false,
          "type": "bool"
        }
      },
      "torch.nn.InstanceNorm2d": {
        "affine": {
          "def": "a boolean value that when set to True, this module has learnable affine parameters, initialized the same way as done for batch normalization",
          "isRequired": false,
          "type": "bool"
        },
        "eps": {
          "def": "a value added to the denominator for numerical stability",
          "isRequired": false,
          "type": "float"
        },
        "momentum": {
          "def": "the value used for the running_mean and running_var computation",
          "isRequired": false,
          "type": "float"
        },
        "num_features": {
          "def": "CCC from an expected input of size (N,C,H,W)(N, C, H, W)(N,C,H,W) or (C,H,W)(C, H, W)(C,H,W)",
          "isRequired": true,
          "type": "int"
        },
        "track_running_stats": {
          "def": "a boolean value that when set to True, this module tracks the running mean and variance, and when set to False, this module does not track such statistics and always uses batch statistics in both training and eval modes",
          "isRequired": false,
          "type": "bool"
        }
      },
      "torch.nn.InstanceNorm3d": {
        "affine": {
          "def": "a boolean value that when set to True, this module has learnable affine parameters, initialized the same way as done for batch normalization",
          "isRequired": false,
          "type": "bool"
        },
        "eps": {
          "def": "a value added to the denominator for numerical stability",
          "isRequired": false,
          "type": "float"
        },
        "momentum": {
          "def": "the value used for the running_mean and running_var computation",
          "isRequired": false,
          "type": "float"
        },
        "num_features": {
          "def": "CCC from an expected input of size (N,C,D,H,W)(N, C, D, H, W)(N,C,D,H,W) or (C,D,H,W)(C, D, H, W)(C,D,H,W)",
          "isRequired": true,
          "type": "int"
        },
        "track_running_stats": {
          "def": "a boolean value that when set to True, this module tracks the running mean and variance, and when set to False, this module does not track such statistics and always uses batch statistics in both training and eval modes",
          "isRequired": false,
          "type": "bool"
        }
      }
    },
    "tensorflow": {}
  },
  "LRN": {
    "mindspore": {
      "mindspore.nn.LRN": {
        "alpha": {
          "def": "A scale factor, usually positive. Default: 1.0 .",
          "isRequired": false,
          "type": "float"
        },
        "beta": {
          "def": "An exponent. Default: 0.5 .",
          "isRequired": false,
          "type": "float"
        },
        "depth_radius": {
          "def": "Half-width of the 1-D normalization window with the shape of 0-D. Default: 5 .",
          "isRequired": false,
          "type": "int"
        },
        "bias": {
          "def": "An offset (usually positive to avoid dividing by 0). Default: 1.0 .",
          "isRequired": false,
          "type": "float"
        },
        "norm_region": {
          "def": " Specifies normalization region. Options: \"ACROSS_CHANNELS\" . Default: \"ACROSS_CHANNELS\"",
          "isRequired": true,
          "type": "str"
        }
      }
    },
    "onnx": {
      "alpha": {
        "def": "Scaling parameter.",
        "type": "float"
      },
      "beta": {
        "def": "The exponent.",
        "type": "float"
      },
      "bias": {
        "def": "",
        "type": "float"
      },
      "size": {
        "def": "The number of channels to sum over",
        "type": "int"
      }
    },
    "paddlepaddle": {
      "paddle.nn.LocalResponseNorm": {
        "alpha": {
          "def": "The scaling parameter, positive. Default:1e-4",
          "isRequired": false,
          "type": "float"
        },
        "beta": {
          "def": "The exponent, positive. Default:0.75",
          "isRequired": false,
          "type": "float"
        },
        "data_format": {
          "def": "Specify the data format of the input, and the data format of the output will be consistent with that of the input. An optional string from: If input is 3-D tensor, the string could be \u201cNCL\u201d or \u201cNLC\u201d . When it is \u201cNCL\u201d, the data is stored in the order of: [batch_size, input_channels, feature_length]. If input is 4-D tensor, the string could be \u201cNCHW\u201d, \u201cNHWC\u201d. When it is \u201cNCHW\u201d, the data is stored in the order of: [batch_size, input_channels, input_height, input_width]. If input is 5-D tensor, the string could be \u201cNCDHW\u201d, \u201cNDHWC\u201d . When it is \u201cNCDHW\u201d, the data is stored in the order of: [batch_size, input_channels, input_depth, input_height, input_width].",
          "isRequired": false,
          "type": "str"
        },
        "k": {
          "def": "An offset, positive. Default: 1.0",
          "isRequired": false,
          "type": "float"
        },
        "name": {
          "def": "Name for the operation (optional, default is None). For more information, please refer to Name.",
          "isRequired": false,
          "type": "str"
        },
        "size": {
          "def": "The number of channels to sum over.",
          "isRequired": true,
          "type": "int"
        }
      }
    },
    "pytorch": {
      "torch.nn.LocalResponseNorm": {
        "alpha": {
          "def": "multiplicative factor",
          "isRequired": false,
          "type": "float"
        },
        "beta": {
          "def": "exponent",
          "isRequired": false,
          "type": "float"
        },
        "k": {
          "def": "additive factor",
          "isRequired": false,
          "type": "float"
        },
        "size": {
          "def": "amount of neighbouring channels used for normalization",
          "isRequired": true,
          "type": "int"
        }
      }
    },
    "tensorflow": {
      "tf.raw_ops.LRN": {
        "alpha": {
          "def": "An optional float. Defaults to 1. A scale factor, usually positive.",
          "isRequired": false,
          "type": "float"
        },
        "beta": {
          "def": "An optional float. Defaults to 0.5. An exponent.",
          "isRequired": false,
          "type": "float"
        },
        "bias": {
          "def": "An optional float. Defaults to 1. An offset (usually positive to avoid dividing by 0).",
          "isRequired": false,
          "type": "float"
        },
        "depth_radius": {
          "def": "An optional int. Defaults to 5. 0-D. Half-width of the 1-D normalization window.",
          "isRequired": false,
          "type": "int"
        },
        "input": {
          "def": "A tensor. Must be one of the following types: half, bfloat16, float32. 4-D.",
          "isRequired": true,
          "type": "tensor"
        },
        "name": {
          "def": "A name for the operation (optional).",
          "isRequired": false,
          "type": "string"
        }
      }
    }
  },
  "LayerNormalization": {
    "mindspore": {
      "mindspore.nn.LayerNorm": {
        "begin_norm_axis": {
          "def": "The first normalization dimension: normalization will be performed along dimensions begin_norm_axis: R, the value should be in [-1, R). Default: -1 .",
          "isRequired": false,
          "type": "int"
        },
        "begin_params_axis": {
          "def": "The begin axis of the parameter input \\((\\gamma, \\beta)\\) to apply LayerNorm, the value should be in [-1, R). Default: -1 .",
          "isRequired": false,
          "type": "int"
        },
        "beta_init": {
          "def": "Initializer for the \\(\\beta\\) weight. The values of str refer to the function initializer including 'zeros' , 'ones' , 'xavier_uniform' , 'he_uniform' , etc. Default: 'zeros' .",
          "isRequired": false,
          "type": "Union[tensor, str, Initializer, numbers.Number]"
        },
        "dtype": {
          "def": "Dtype of Parameters. Default: mstype.float32 .",
          "isRequired": false,
          "type": "mindspore.dtype"
        },
        "epsilon": {
          "def": "A value added to the denominator for numerical stability(\\(\\epsilon\\)). Default: 1e-7 .",
          "isRequired": false,
          "type": "float"
        },
        "gamma_init": {
          "def": "Initializer for the \\(\\gamma\\) weight. The values of str refer to the function initializer including 'zeros' , 'ones' , 'xavier_uniform' , 'he_uniform' , etc. Default: 'ones' .",
          "isRequired": false,
          "type": "Union[tensor, str, Initializer, numbers.Number]"
        },
        "normalized_shape": {
          "def": "The normalization is performed over axis begin_norm_axis \u2026 R - 1. R is the dimension size of input x.",
          "isRequired": true,
          "type": "Union(tuple[int], list[int]"
        }
      }
    },
    "onnx": {
      "axis": {
        "def": "The first normalization dimension",
        "type": "int"
      },
      "epsilon": {
        "def": "The epsilon value to use to avoid division by zero.",
        "type": "float"
      },
      "stash_type": {
        "def": "Type of Mean and InvStdDev",
        "type": "int"
      }
    },
    "paddlepaddle": {
      "paddle.nn.LayerNorm": {
        "bias_attr": {
          "def": "The parameter attribute for the learnable bias \\(b\\). If is False, bias is None. If is None, a default ParamAttr would be added as bias. The bias_attr is initialized as 0 if it is added. Default: None. For more information, please refer to ParamAttr .",
          "isRequired": false,
          "type": "ParamAttr|bool"
        },
        "epsilon": {
          "def": "The small value added to the variance to prevent division by zero. Default: 1e-05.",
          "isRequired": false,
          "type": "float"
        },
        "name": {
          "def": "Name for the LayerNorm, default is None. For more information, please refer to Name .",
          "isRequired": false,
          "type": "str"
        },
        "normalized_shape": {
          "def": "Input shape from an expected input of size \\([*, normalized_shape[0], normalized_shape[1], ..., normalized_shape[-1]]\\). If it is a single integer, this module will normalize over the last dimension which is expected to be of that specific size.",
          "isRequired": true,
          "type": "int|list|tuple"
        },
        "weight_attr": {
          "def": "The parameter attribute for the learnable gain \\(g\\). If False, weight is None. If is None, a default ParamAttr would be added as scale. The param_attr is initialized as 1 if it is added. Default: None. For more information, please refer to ParamAttr .",
          "isRequired": false,
          "type": "ParamAttr|bool"
        }
      }
    },
    "pytorch": {
      "torch.nn.LayerNorm": {
        "bias": {
          "def": "If set to False, the layer will not learn an additive bias (only relevant if elementwise_affine is True)",
          "isRequired": false,
          "type": "bool"
        },
        "elementwise_affine": {
          "def": "a boolean value that when set to True, this module has learnable per-element affine parameters initialized to ones (for weights) and zeros (for biases)",
          "isRequired": false,
          "type": "bool"
        },
        "eps": {
          "def": "a value added to the denominator for numerical stability",
          "isRequired": false,
          "type": "float"
        },
        "normalized_shape": {
          "def": "input shape from an expected input of size",
          "isRequired": true,
          "type": "int or list or torchsize"
        }
      }
    },
    "tensorflow": {
      "tf.keras.layers.LayerNormalization": {
        "axis": {
          "def": "Integer or List/Tuple. The axis or axes to normalize across. Typically, this is the features axis/axes. The left-out axes are typically the batch axis/axes. -1 is the last dimension in the input. Defaults to -1.",
          "isRequired": false,
          "type": "int"
        },
        "beta_constraint": {
          "def": "Optional constraint for the beta weight. None by default.",
          "isRequired": false,
          "type": "string"
        },
        "beta_initializer": {
          "def": "Initializer for the beta weight. Defaults to zeros.",
          "isRequired": false,
          "type": "string"
        },
        "beta_regularizer": {
          "def": "Optional regularizer for the beta weight. None by default.",
          "isRequired": false,
          "type": "string"
        },
        "center": {
          "def": "If True, add offset of beta to normalized tensor. If False, beta is ignored. Defaults to True.",
          "isRequired": false,
          "type": "bool"
        },
        "epsilon": {
          "def": "Small float added to variance to avoid dividing by zero. Defaults to 1e-3",
          "isRequired": false,
          "type": "float"
        },
        "gamma_constraint": {
          "def": "Optional constraint for the gamma weight. None by default.",
          "isRequired": false,
          "type": "string"
        },
        "gamma_initializer": {
          "def": "Initializer for the gamma weight. Defaults to ones.",
          "isRequired": false,
          "type": "string"
        },
        "gamma_regularizer": {
          "def": "Optional regularizer for the gamma weight. None by default.",
          "isRequired": false,
          "type": "string"
        },
        "scale": {
          "def": "If True, multiply by gamma. If False, gamma is not used. When the next layer is linear (also e.g. nn.relu), this can be disabled since the scaling will be done by the next layer. Defaults to True.",
          "isRequired": false,
          "type": "bool"
        }
      }
    }
  },
  "LeakyRelu": {
    "mindspore": {
      "mindspore.nn.LeakyReLU": {
        "alpha": {
          "def": "Slope of the activation function at x < 0. Default: 0.2 .",
          "isRequired": false,
          "type": "float"
        }
      }
    },
    "onnx": {
      "alpha": {
        "def": "Coefficient of leakage.",
        "type": "float"
      }
    },
    "paddlepaddle": {
      "paddle.nn.LeakyReLU": {
        "name": {
          "def": "Name for the operation (optional, default is None). For more information, please refer to Name.",
          "isRequired": false,
          "type": "str"
        },
        "negative_slope": {
          "def": "Slope of the activation function at \\(x < 0\\) . Default is 0.01.",
          "isRequired": false,
          "type": "float"
        }
      }
    },
    "pytorch": {
      "torch.nn.LeakyReLU": {
        "inplace": {
          "def": "can optionally do the operation in-place",
          "isRequired": false,
          "type": "bool"
        },
        "negative_slope": {
          "def": "Controls the angle of the negative slope (which is used for negative input values)",
          "isRequired": false,
          "type": "float"
        }
      }
    },
    "tensorflow": {
      "tf.keras.layers.LeakyReLU": {
        "alpha": {
          "def": "Float >= 0.. Negative slope coefficient. Defaults to 0.3.",
          "isRequired": false,
          "type": "float"
        }
      }
    }
  },
  "LogSoftmax": {
    "mindspore": {
      "mindspore.nn.LogSoftmax": {
        "axis": {
          "def": "The axis to apply LogSoftmax operation, -1 means the last dimension. Default: -1 .",
          "isRequired": false,
          "type": "int"
        }
      }
    },
    "onnx": {
      "axis": {
        "def": " Describes the dimension LogSoftmax will be performed on",
        "type": "int"
      }
    },
    "paddlepaddle": {
      "paddle.nn.LogSoftmax": {
        "axis": {
          "def": "The axis along which to perform log_softmax calculations. It should be in range [-D, D), where D is the dimensions of the input tensor . If axis < 0, it works the same way as \\(axis + D\\) . Default is -1.",
          "isRequired": false,
          "type": "int"
        },
        "name": {
          "def": "Name for the operation (optional, default is None). For more information, please refer to Name.",
          "isRequired": false,
          "type": "str"
        }
      }
    },
    "pytorch": {
      "torch.nn.LogSoftmax": {
        "dim": {
          "def": " dimension along which LogSoftmax will be computed.",
          "isRequired": false,
          "type": "int"
        }
      }
    },
    "tensorflow": {}
  },
  "LpPool": {
    "mindspore": {
      "mindspore.nn.LPPool1d": {
        "ceil_mode": {
          "def": "Whether to use ceil or floor to calculate output shape. Default: False .",
          "isRequired": false,
          "type": "bool"
        },
        "kernel_size": {
          "def": "The size of kernel window.",
          "isRequired": true,
          "type": "int"
        },
        "norm_type": {
          "def": "Type of normalization, represents \\(p\\) in the formula, can not be 0.  if p = 1, the result is the sum of the elements within the pooling kernel(proportional to average pooling). if p = \\(\\infty\\), the result is the result of maximum pooling.",
          "isRequired": true,
          "type": "Union[int, float]"
        },
        "stride": {
          "def": "The distance of kernel moving, an int number that represents the width of movement is stride, if the value is None, the default value kernel_size is used. Default: None .",
          "isRequired": false,
          "type": "int"
        }
      },
      "mindspore.nn.LPPool2d": {
        "ceil_mode": {
          "def": "Whether to use ceil or floor to calculate output shape. Default: False .",
          "isRequired": false,
          "type": "bool"
        },
        "kernel_size": {
          "def": "The size of kernel window. The data type of kernel_size must be int and the value represents the height and width, or a tuple of two int numbers that represent height and width respectively.",
          "isRequired": true,
          "type": "Union[int, tuple[int]]"
        },
        "norm_type": {
          "def": "if p = 1, the result is the sum of the elements within the pooling kernel(proportional to average pooling). if p = \\(\\infty\\), the result is the result of maximum pooling.",
          "isRequired": true,
          "type": "Union[int, float]"
        },
        "stride": {
          "def": "The distance of kernel moving, an int number that represents the height and width of movement are both stride, or a tuple of two int numbers that represent height and width of movement respectively, if the value is None, the default value kernel_size is used. Default: None .",
          "isRequired": false,
          "type": "Union[int, tuple[int]]"
        }
      }
    },
    "onnx": {
      "auto_pad": {
        "def": "auto_pad must be either NOTSET, SAME_UPPER, SAME_LOWER or VALID.Where default value is NOTSET, which means explicit padding is used.SAME_UPPER or SAME_LOWER mean pad the input so that output_shape[i] = ceil(input_shape[i] / strides[i]) for each axis i",
        "type": "string"
      },
      "ceil_mode": {
        "def": "Whether to use ceil or floor (default) to compute the output shape.",
        "type": "int"
      },
      "dilations": {
        "def": "dilation value along each spatial axis of the filter",
        "type": "ints"
      },
      "kernel_shape": {
        "def": "The size of the kernel along each axis.",
        "type": "ints"
      },
      "p": {
        "def": "p value of the Lp norm used to pool over the input data.",
        "type": "int"
      },
      "pads": {
        "def": "Padding for the beginning and ending along each spatial axis, it cantake any value greater than or equal to 0",
        "type": "ints"
      },
      "strides": {
        "def": "Stride along each spatial axis",
        "type": "ints"
      }
    },
    "paddlepaddle": {},
    "pytorch": {
      "torch.nn.LPPool1d": {
        "ceil_mode": {
          "def": "when True, will use ceil instead of floor to compute the output shape",
          "isRequired": false,
          "type": "bool"
        },
        "kernel_size": {
          "def": "a single int, the size of the window",
          "isRequired": true,
          "type": "int"
        },
        "norm_type": {
          "def": "",
          "isRequired": true,
          "type": "int"
        },
        "stride": {
          "def": "a single int, the stride of the window",
          "isRequired": false,
          "type": "int"
        }
      },
      "torch.nn.LPPool2d": {
        "ceil_mode": {
          "def": "when True, will use ceil instead of floor to compute the output shape",
          "isRequired": false,
          "type": "bool"
        },
        "kernel_size": {
          "def": "the size of the window",
          "isRequired": true,
          "type": "unionint tupleint int"
        },
        "norm_type": {
          "def": "",
          "isRequired": true,
          "type": "int"
        },
        "stride": {
          "def": "the stride of the window",
          "isRequired": false,
          "type": "unionint tupleint int"
        }
      }
    },
    "tensorflow": {}
  },
  "Max": {
    "mindspore": {
      "mindspore.ops.maximum": {
        "input": {
          "def": "The first input is a number or a bool or a tensor whose data type is number or bool.",
          "isRequired": true,
          "type": "Union[tensor, Number, bool]"
        },
        "other": {
          "def": "The second input is a number or a bool when the first input is a tensor or a tensor whose data type is number or bool.",
          "isRequired": true,
          "type": "Union[tensor, Number, bool]"
        }
      }
    },
    "onnx": {
      "consumed_inputs": {
        "def": "legacy optimization attribute.",
        "type": "ints"
      }
    },
    "paddlepaddle": {
      "paddle.maximum": {
        "name": {
          "def": "Name for the operation (optional, default is None). For more information, please refer to Name.",
          "isRequired": false,
          "type": "str"
        },
        "x": {
          "def": "the input tensor, it\u2019s data type should be float32, float64, int32, int64.",
          "isRequired": true,
          "type": "tensor"
        },
        "y": {
          "def": "the input tensor, it\u2019s data type should be float32, float64, int32, int64.",
          "isRequired": true,
          "type": "tensor"
        }
      }
    },
    "pytorch": {
      "torch.maximum": {
        "input": {
          "def": "the input tensor.",
          "isRequired": true,
          "type": "tensor"
        },
        "other": {
          "def": "the second input tensor",
          "isRequired": true,
          "type": "tensor"
        }
      }
    },
    "tensorflow": {
      "tf.keras.layers.maximum": {
        "inputs": {
          "def": "A list of input tensors of same shape.",
          "isRequired": true,
          "type": "tensors"
        },
        "name": {
          "def": "A name for the operation (optional).",
          "isRequired": false,
          "type": "string"
        }
      },
      "tf.math.maximum": {
        "name": {
          "def": "A name for the operation (optional).",
          "isRequired": false,
          "type": "string"
        },
        "x": {
          "def": "A tensor. Must be one of the following types: bfloat16, half, float32, float64, int8, uint8, int16, uint16, int32, uint32, int64, uint64.",
          "isRequired": true,
          "type": "tensor"
        },
        "y": {
          "def": "A tensor. Must have the same type as x.",
          "isRequired": true,
          "type": "tensor"
        }
      }
    }
  },
  "MaxPool": {
    "mindspore": {
      "mindspore.nn.MaxPool1d": {
        "ceil_mode": {
          "def": "If True, use ceil to compute the output shape instead of floor. Default: False .",
          "isRequired": false,
          "type": "bool"
        },
        "dilation": {
          "def": "The spacing between the elements of the kernel in convolution, used to increase the receptive field of the pooling operation. If it is a tuple, its length can only be 1. Default: 1 .",
          "isRequired": false,
          "type": "Union(int, tuple[int]"
        },
        "kernel_size": {
          "def": "The size of kernel used to take the max value, Default: 1 .",
          "isRequired": false,
          "type": "int"
        },
        "pad_mode": {
          "def": "Specifies the padding mode with a padding value of 0. It can be set to: \"same\" , \"valid\" or \"pad\" . Default: \"valid\" .  \"same\": Pad the input at the begin and end so that the shape of input and output are the same when stride is set to 1. The amount of padding to is calculated by the operator internally. If the amount is even, it is uniformly distributed around the input, if it is odd, the excess padding is goes to the right side. If this mode is set, padding must be 0. \"valid\": No padding is applied to the input, and the output returns the maximum possible length. Extra pixels that could not complete a full stride will be discarded. If this mode is set, padding must be 0. \"pad\": Pad the input with a specified amount. In this mode, the amount of padding at the begin and end is determined by the padding parameter. If this mode is set, padding must be greater than or equal to 0.",
          "isRequired": false,
          "type": "str"
        },
        "padding": {
          "def": "Padding value for the pooling. Default value is 0. padding can only be an integer or a tuple/list containing a single integer, in which case padding times or padding[0] times are padded on both sides of the input.",
          "isRequired": false,
          "type": "Union(int, tuple[int], list[int]"
        },
        "return_indices": {
          "def": "If True , the function will return both the result of max pooling and the indices of the max elements. Default: False .",
          "isRequired": false,
          "type": "bool"
        },
        "stride": {
          "def": "The distance of kernel moving, an int number that represents the width of movement is stride, Default: 1 .",
          "isRequired": false,
          "type": "int"
        }
      },
      "mindspore.nn.MaxPool2d": {
        "ceil_mode": {
          "def": "If True , use ceil to compute the output shape instead of floor. Default: False .",
          "isRequired": false,
          "type": "bool"
        },
        "data_format": {
          "def": "The optional value for data format, is 'NHWC' or 'NCHW' . Default: 'NCHW' .",
          "isRequired": false,
          "type": "str"
        },
        "dilation": {
          "def": "The spacing between the elements of the kernel in convolution, used to increase the receptive field of the pooling operation. If it is a tuple, it must contain one or two integers. Default: 1 .",
          "isRequired": false,
          "type": "Union(int, tuple[int]"
        },
        "kernel_size": {
          "def": "The size of kernel used to take the max value, is an int number or a single element tuple that represents height and width are both kernel_size, or a tuple of two int numbers that represent height and width respectively. Default: 1 .",
          "isRequired": false,
          "type": "Union[int, tuple[int]]"
        },
        "pad_mode": {
          "def": "Specifies the padding mode with a padding value of 0. It can be set to: \"same\" , \"valid\" or \"pad\" . Default: \"valid\" .  \"same\": Pad the input around its edges so that the shape of input and output are the same when stride is set to 1. The amount of padding to is calculated by the operator internally, If the amount is even, it is uniformly distributed around the input, if it is odd, the excess amount goes to the right/bottom side. If this mode is set, padding must be 0. \"valid\": No padding is applied to the input, and the output returns the maximum possible height and width. Extra pixels that could not complete a full stride will be discarded. If this mode is set, padding must be 0. \"pad\": Pad the input with a specified amount. In this mode, the amount of padding in the height and width directions is determined by the padding parameter. If this mode is set, padding must be greater than or equal to 0.",
          "isRequired": false,
          "type": "str"
        },
        "padding": {
          "def": "Specifies the padding value of the pooling operation. Default: 0 . padding can only be an integer or a tuple/list containing one or two integers. If padding is an integer or a tuple/list containing one integer, it will be padded padding times in the four directions of the input. If padding is a tuple/list containing two integers, it will be padded padding[0] times in the up-down direction of the input and padding[1] times in the left-right direction of the input.",
          "isRequired": false,
          "type": "Union(int, tuple[int], list[int]"
        },
        "return_indices": {
          "def": "If True , the function will return both the result of max pooling and the indices of the max elements. Default: False .",
          "isRequired": false,
          "type": "bool"
        },
        "stride": {
          "def": "The distance of kernel moving, an int number or a single element tuple that represents the height and width of movement are both stride, or a tuple of two int numbers that represent height and width of movement respectively. Default: 1 .",
          "isRequired": false,
          "type": "Union[int, tuple[int]]"
        }
      },
      "mindspore.nn.MaxPool3d": {
        "ceil_mode": {
          "def": "Whether to use ceil or floor to calculate output shape. Default: False .",
          "isRequired": false,
          "type": "bool"
        },
        "dilation": {
          "def": "The spacing between the elements of the kernel in convolution, used to increase the receptive field of the pooling operation. If it is a tuple, it must contain one or three integers. Default: 1 .",
          "isRequired": false,
          "type": "Union(int, tuple[int]"
        },
        "kernel_size": {
          "def": "The size of kernel used to take the maximum value, is an int number or a single element tuple that represents depth, height and width of the kernel, or a tuple of three int numbers that represent depth, height and width respectively. The value must be a positive integer. Default: 1 .",
          "isRequired": false,
          "type": "Union[int, tuple[int]]"
        },
        "pad_mode": {
          "def": "Specifies the padding mode with a padding value of 0. It can be set to: \"same\" , \"valid\" or \"pad\" . Default: \"valid\" .  \"same\": Pad the input around its depth/height/width dimension so that the shape of input and output are the same when stride is set to 1. The amount of padding to is calculated by the operator internally.  If the amount is even, it isuniformly distributed around the input, if it is odd, the excess amount goes to the front/right/bottom side. If this mode is set, padding must be 0. \"valid\": No padding is applied to the input, and the output returns the maximum possible depth, height and width. Extra pixels that could not complete a full stride will be discarded. If this mode is set, padding must be 0. \"pad\": Pad the input with a specified amount. In this mode, the amount of padding in the depth, height and width dimension is determined by the padding parameter. If this mode is set, padding must be greater than or equal to 0.",
          "isRequired": false,
          "type": "str"
        },
        "padding": {
          "def": "Pooling padding value. Default: 0 . padding can only be an integer or a tuple/list containing one or three integers. If padding is an integer or a tuple/list containing one integer, it will be padded in six directions of front, back, top, bottom, left and right of the input. If padding is a tuple/list containing three integers, it will be padded in front and back of the input padding[0] times, up and down padding[1] times, and left and right of the input padding[2] times.",
          "isRequired": false,
          "type": "Union(int, tuple[int], list[int]"
        },
        "return_indices": {
          "def": "If True , output is a Tuple of 2 tensors, representing the maxpool result and where the max values are generated. Otherwise, only the maxpool result is returned. Default: False .",
          "isRequired": false,
          "type": "bool"
        },
        "stride": {
          "def": "The moving stride of pooling operation, an int number or a single element tuple that represents the moving stride of pooling kernel in the directions of depth, height and the width, or a tuple of three int numbers that represent depth, height and width of movement respectively. The value must be a positive integer. If the value is None, the default value kernel_size is used. Default: 1 .",
          "isRequired": false,
          "type": "Union[int, tuple[int]]"
        }
      }
    },
    "onnx": {
      "auto_pad": {
        "def": "auto_pad must be either NOTSET, SAME_UPPER, SAME_LOWER or VALID.Where default value is NOTSET, which means explicit padding is used.SAME_UPPER or SAME_LOWER mean pad the input so that output_shape[i] = ceil(input_shape[i] / strides[i]) for each axis i",
        "type": "string"
      },
      "ceil_mode": {
        "def": "Whether to use ceil or floor (default) to compute the output shape.",
        "type": "int"
      },
      "dilations": {
        "def": "Dilation value along each spatial axis of filter",
        "type": "ints"
      },
      "kernel_shape": {
        "def": "The size of the kernel along each axis.",
        "type": "ints"
      },
      "pads": {
        "def": "Padding for the beginning and ending along each spatial axis, it cantake any value greater than or equal to 0",
        "type": "ints"
      },
      "storage_order": {
        "def": "The storage order of the tensor",
        "type": "int"
      },
      "strides": {
        "def": "Stride along each spatial axis",
        "type": "ints"
      }
    },
    "paddlepaddle": {
      "paddle.nn.MaxPool1D": {
        "ceil_mode": {
          "def": "Whether to use the ceil function to calculate output height and width. False is the default. If it is set to False, the floor function will be used. Default False.",
          "isRequired": false,
          "type": "bool"
        },
        "kernel_size": {
          "def": "The pool kernel size. If pool kernel size is a tuple or list, it must contain an integer.",
          "isRequired": true,
          "type": "int|list|tuple"
        },
        "name": {
          "def": "For detailed information, please refer to Name. Usually name is no need to set and None by default.",
          "isRequired": false,
          "type": "str"
        },
        "padding": {
          "def": "The padding size. Padding could be in one of the following forms. 1. A string in [\u2018valid\u2019, \u2018same\u2019]. 2. An integer, which means the feature map is zero padded by size of padding on every sides. 3. A list[int] or tuple(int) whose length is 1, which means the feature map is zero padded by the size of padding[0] on every sides. 4. A list[int] or tuple(int) whose length is 2, It has the form [pad_before, pad_after]. 5. A list or tuple of pairs of integers. It has the form [[pad_before, pad_after], [pad_before, pad_after], \u2026]. Note that, the batch dimension and channel dimension should be [0,0] or(0,0). The default value is 0.",
          "isRequired": false,
          "type": "str|int|list|tuple"
        },
        "return_mask": {
          "def": "Whether return the max indices along with the outputs. default is False.",
          "isRequired": false,
          "type": "bool"
        },
        "stride": {
          "def": "The pool stride size. If pool stride size is a tuple or list, it must contain an integer. Default None, then stride will be equal to the kernel_size.",
          "isRequired": false,
          "type": "int|list|tuple"
        }
      },
      "paddle.nn.MaxPool2D": {
        "ceil_mode": {
          "def": "when True, will use ceil instead of floor to compute the output shape",
          "isRequired": false,
          "type": "bool"
        },
        "data_format": {
          "def": "The data format of the input and output data. An optional string from: \u201cNCHW\u201d, \u201cNDHW\u201d. The default is \u201cNCHW\u201d. When it is \u201cNCHW\u201d, the data is stored in the order of: [batch_size, input_channels, input_height, input_width].",
          "isRequired": false,
          "type": "str"
        },
        "kernel_size": {
          "def": "The pool kernel size. If pool kernel size is a tuple or list, it must contain two integers, (pool_size_Height, pool_size_Width). Otherwise, the pool kernel size will be a square of an int.",
          "isRequired": true,
          "type": "int|list|tuple"
        },
        "name": {
          "def": "For detailed information, please refer to Name. Usually name is no need to set and None by default.",
          "isRequired": false,
          "type": "str"
        },
        "padding": {
          "def": "The padding size. Padding could be in one of the following forms. 1. A string in [\u2018valid\u2019, \u2018same\u2019]. 2. An int, which means the feature map is zero padded by size of padding on every sides. 3. A list[int] or tuple(int) whose length is 2, [pad_height, pad_weight] whose value means the padding size of each dimension. 4. A list[int] or tuple(int) whose length is 4. [pad_height_top, pad_height_bottom, pad_width_left, pad_width_right] whose value means the padding size of each side. 5. A list or tuple of pairs of integers. It has the form [[pad_before, pad_after], [pad_before, pad_after], \u2026]. Note that, the batch dimension and channel dimension should be [0,0] or (0,0). The default value is 0.",
          "isRequired": false,
          "type": "str|int|list|tuple"
        },
        "return_mask": {
          "def": "Whether to return the max indices along with the outputs.",
          "isRequired": false,
          "type": "bool"
        },
        "stride": {
          "def": "The pool stride size. If pool stride size is a tuple or list, it must contain two integers, (pool_stride_Height, pool_stride_Width). Otherwise, the pool stride size will be a square of an int. Default None, then stride will be equal to the kernel_size.",
          "isRequired": false,
          "type": "int|list|tuple"
        }
      },
      "paddle.nn.MaxPool3D": {
        "ceil_mode": {
          "def": "${ceil_mode_comment}",
          "isRequired": false,
          "type": "bool"
        },
        "data_format": {
          "def": "The data format of the input and output data. An optional string from: \u201cNCDHW\u201d, \u201cNDHWC\u201d. The default is \u201cNCDHW\u201d. When it is \u201cNCDHW\u201d, the data is stored in the order of: [batch_size, input_channels, input_depth, input_height, input_width].",
          "isRequired": false,
          "type": "str"
        },
        "kernel_size": {
          "def": "The pool kernel size. If the kernel size is a tuple or list, it must contain three integers, (kernel_size_Depth, kernel_size_Height, kernel_size_Width). Otherwise, the pool kernel size will be the cube of an int.",
          "isRequired": true,
          "type": "int|list|tuple"
        },
        "name": {
          "def": "For detailed information, please refer to Name. Usually name is no need to set and None by default.",
          "isRequired": false,
          "type": "str"
        },
        "padding": {
          "def": "The padding size. Padding could be in one of the following forms. 1. A string in [\u2018valid\u2019, \u2018same\u2019]. 2. An int, which means the feature map is zero padded by size of padding on every sides. 3. A list[int] or tuple(int) whose length is 3, [pad_depth, pad_height, pad_weight] whose value means the padding size of each dimension. 4. A list[int] or tuple(int) whose length is . [pad_depth_front, pad_depth_back, pad_height_top, pad_height_bottom, pad_width_left, pad_width_right] whose value means the padding size of each side. 5. A list or tuple of pairs of integers. It has the form [[pad_before, pad_after], [pad_before, pad_after], \u2026]. Note that, the batch dimension and channel dimension should be [0,0] or (0,0). The default value is 0.",
          "isRequired": false,
          "type": "str|int|list|tuple"
        },
        "return_mask": {
          "def": "Whether to return the max indices along with the outputs.",
          "isRequired": false,
          "type": "bool"
        },
        "stride": {
          "def": "The pool stride size. If pool stride size is a tuple or list, it must contain three integers, [stride_Depth, stride_Height, stride_Width). Otherwise, the pool stride size will be a cube of an int. Default None, then stride will be equal to the kernel_size.",
          "isRequired": false,
          "type": "int|list|tuple"
        }
      }
    },
    "pytorch": {
      "torch.nn.MaxPool1d": {
        "ceil_mode": {
          "def": "If True, will use ceil instead of floor to compute the output shape",
          "isRequired": false,
          "type": "bool"
        },
        "dilation": {
          "def": "The stride between elements within a sliding window, must be > 0.",
          "isRequired": false,
          "type": "ints"
        },
        "kernel_size": {
          "def": "The size of the sliding window, must be > 0.",
          "isRequired": true,
          "type": "ints"
        },
        "padding": {
          "def": "Implicit negative infinity padding to be added on both sides, must be >= 0 and <= kernel_size / 2.",
          "isRequired": false,
          "type": "ints"
        },
        "return_indices": {
          "def": "If True, will return the argmax along with the max values",
          "isRequired": false,
          "type": "bool"
        },
        "stride": {
          "def": "The stride of the sliding window, must be > 0",
          "isRequired": false,
          "type": "ints"
        }
      },
      "torch.nn.MaxPool2d": {
        "ceil_mode": {
          "def": "when True, will use ceil instead of floor to compute the output shape",
          "isRequired": false,
          "type": "bool"
        },
        "dilation": {
          "def": "a parameter that controls the stride of elements in the window",
          "isRequired": false,
          "type": "unionint tupleint int"
        },
        "kernel_size": {
          "def": "the size of the window to take a max over",
          "isRequired": true,
          "type": "unionint tupleint int"
        },
        "padding": {
          "def": "Implicit negative infinity padding to be added on both sides",
          "isRequired": false,
          "type": "unionint tupleint int"
        },
        "return_indices": {
          "def": "if True, will return the max indices along with the outputs",
          "isRequired": false,
          "type": "bool"
        },
        "stride": {
          "def": "the stride of the window",
          "isRequired": false,
          "type": "unionint tupleint int"
        }
      },
      "torch.nn.MaxPool3d": {
        "ceil_mode": {
          "def": "when True, will use ceil instead of floor to compute the output shape",
          "isRequired": false,
          "type": "bool"
        },
        "dilation": {
          "def": "a parameter that controls the stride of elements in the window",
          "isRequired": false,
          "type": "unionint tupleint int int"
        },
        "kernel_size": {
          "def": "the size of the window to take a max over",
          "isRequired": true,
          "type": "unionint tupleint int int"
        },
        "padding": {
          "def": "Implicit negative infinity padding to be added on all three sides",
          "isRequired": false,
          "type": "unionint tupleint int int"
        },
        "return_indices": {
          "def": "if True, will return the max indices along with the outputs",
          "isRequired": false,
          "type": "bool"
        },
        "stride": {
          "def": "the stride of the window",
          "isRequired": false,
          "type": "unionint tupleint int int"
        }
      }
    },
    "tensorflow": {
      "tf.keras.layers.MaxPooling1D": {
        "data_format": {
          "def": "A string, one of channels_last (default) or channels_first. The ordering of the dimensions in the inputs. channels_last corresponds to inputs with shape (batch, steps, features) while channels_first corresponds to inputs with shape (batch, features, steps).",
          "isRequired": false,
          "type": "string"
        },
        "padding": {
          "def": "One of \"valid\" or \"same\" (case-insensitive). \"valid\" means no padding. \"same\" results in padding evenly to the left/right or up/down of the input such that output has the same height/width dimension as the input.",
          "isRequired": false,
          "type": "string"
        },
        "pool_size": {
          "def": "Integer, size of the max pooling window.",
          "isRequired": false,
          "type": "int"
        },
        "strides": {
          "def": "Integer, or None. Specifies how much the pooling window moves for each pooling step. If None, it will default to pool_size.",
          "isRequired": false,
          "type": "int"
        }
      },
      "tf.keras.layers.MaxPooling2D": {
        "data_format": {
          "def": "A string, one of channels_last (default) or channels_first. The ordering of the dimensions in the inputs. channels_last corresponds to inputs with shape (batch, height, width, channels) while channels_first corresponds to inputs with shape (batch, channels, height, width). When unspecified, uses image_data_format value found in your Keras config file at ~/.keras/keras.json (if exists) else 'channels_last'. Defaults to 'channels_last'.",
          "isRequired": false,
          "type": "string"
        },
        "padding": {
          "def": "One of \"valid\" or \"same\" (case-insensitive). \"valid\" means no padding. \"same\" results in padding evenly to the left/right or up/down of the input such that output has the same height/width dimension as the input.",
          "isRequired": false,
          "type": "string"
        },
        "pool_size": {
          "def": "integer or tuple of 2 integers, window size over which to take the maximum. (2, 2) will take the max value over a 2x2 pooling window. If only one integer is specified, the same window length will be used for both dimensions.",
          "isRequired": false,
          "type": "int"
        },
        "strides": {
          "def": "Integer, tuple of 2 integers, or None. Strides values. Specifies how far the pooling window moves for each pooling step. If None, it will default to pool_size.",
          "isRequired": false,
          "type": "int"
        }
      },
      "tf.keras.layers.MaxPooling3D": {
        "data_format": {
          "def": "A string, one of channels_last (default) or channels_first. The ordering of the dimensions in the inputs. channels_last corresponds to inputs with shape (batch, spatial_dim1, spatial_dim2, spatial_dim3, channels) while channels_first corresponds to inputs with shape (batch, channels, spatial_dim1, spatial_dim2, spatial_dim3). When unspecified, uses image_data_format value found in your Keras config file at ~/.keras/keras.json (if exists) else 'channels_last'. Defaults to 'channels_last'.",
          "isRequired": false,
          "type": "string"
        },
        "padding": {
          "def": "One of \"valid\" or \"same\" (case-insensitive). \"valid\" means no padding. \"same\" results in padding evenly to the left/right or up/down of the input such that output has the same height/width dimension as the input.",
          "isRequired": false,
          "type": "string"
        },
        "pool_size": {
          "def": "Tuple of 3 integers, factors by which to downscale (dim1, dim2, dim3). (2, 2, 2) will halve the size of the 3D input in each dimension.",
          "isRequired": false,
          "type": "int"
        },
        "strides": {
          "def": "tuple of 3 integers, or None. Strides values.",
          "isRequired": false,
          "type": "int"
        }
      }
    }
  },
  "MaxUnpool": {
    "mindspore": {
      "mindspore.nn.MaxUnpool1d": {
        "kernel_size": {
          "def": "The size of kernel used to take the maximum value.",
          "isRequired": true,
          "type": "Union[int, tuple[int]]"
        },
        "padding": {
          "def": "The pad value to be filled. Default: 0 .",
          "isRequired": false,
          "type": "Union[int, tuple[int]]"
        },
        "stride": {
          "def": "The distance of kernel moving, If stride is None, then stride equal to kernel_size. Default: None .",
          "isRequired": false,
          "type": "Union[int, tuple[int]]"
        }
      },
      "mindspore.nn.MaxUnpool2d": {
        "kernel_size": {
          "def": "The size of kernel used to take the maximum value, an int number that represents height and width of the kernel, or a tuple of two int numbers that represent height and width respectively.",
          "isRequired": true,
          "type": "Union[int, tuple[int]]"
        },
        "padding": {
          "def": "The pad value to be filled. Default: 0 . If padding is an integer, the paddings of height and width are the same, equal to padding. If padding is a tuple of two integers, the padding of height and width equal to padding[0] and padding[1] correspondingly.",
          "isRequired": false,
          "type": "Union[int, tuple[int]]"
        },
        "stride": {
          "def": "The distance of kernel moving, an int number that represents the height and width of movement are both stride, or a tuple of two int numbers that represent height and width of movement respectively. If stride is None, then stride equal to kernel_size. Default: None .",
          "isRequired": false,
          "type": "Union[int, tuple[int]]"
        }
      },
      "mindspore.nn.MaxUnpool3d": {
        "kernel_size": {
          "def": "The size of kernel used to take the maximum value, an int number that represents depth, height and width of the kernel, or a tuple of three int numbers that represent depth, height and width respectively.",
          "isRequired": true,
          "type": "Union[int, tuple[int]]"
        },
        "padding": {
          "def": "The pad value to be filled. Default: 0 . If padding is an integer, the paddings of depth, height and width are the same, equal to padding. If padding is a tuple of three integers, the padding of depth, height and width equal to padding[0], padding[1] and padding[2] correspondingly.",
          "isRequired": false,
          "type": "Union[int, tuple[int]]"
        },
        "stride": {
          "def": "The distance of kernel moving, an int number that represents the depth, height and width of movement are both stride, or a tuple of three int numbers that represent depth, height and width of movement respectively. If stride is None, then stride equal to kernel_size. Default: None .",
          "isRequired": false,
          "type": "Union[int, tuple[int]]"
        }
      }
    },
    "onnx": {
      "kernel_shape": {
        "def": "The size of the kernel along each axis.",
        "type": "ints"
      },
      "pads": {
        "def": "Padding for the beginning and ending along each spatial axis, it cantake any value greater than or equal to 0",
        "type": "ints"
      },
      "strides": {
        "def": "Stride along each spatial axis",
        "type": "ints"
      }
    },
    "paddlepaddle": {
      "paddle.nn.MaxUnPool1D": {
        "data_format": {
          "def": "The data format of the input and output data. The default is \u201cNCL\u201d. When it is \u201cNCL\u201d, the data is stored in the order of: [batch_size, input_channels, input_length].",
          "isRequired": false,
          "type": "string"
        },
        "kernel_size": {
          "def": "The unpool kernel size. If unpool kernel size is a tuple or list, it must contain an integer.",
          "isRequired": true,
          "type": "int|list|tuple"
        },
        "name": {
          "def": "For detailed information, please refer to Name. Usually name is no need to set and None by default.",
          "isRequired": false,
          "type": "str"
        },
        "output_size": {
          "def": "The target output size. If output_size is not specified, the actual output shape will be automatically calculated by (input_shape, kernel_size, stride, padding).",
          "isRequired": false,
          "type": "list|tuple"
        },
        "padding": {
          "def": "Padding that was added to the input.",
          "isRequired": false,
          "type": "int | tuple"
        },
        "stride": {
          "def": "The unpool stride size. If unpool stride size is a tuple or list, it must contain an integer.",
          "isRequired": false,
          "type": "int|list|tuple"
        }
      },
      "paddle.nn.MaxUnPool2D": {
        "Input": {
          "def": "\\((N, C, H_{in}, W_{in})\\)",
          "isRequired": true,
          "type": "-"
        },
        "Output": {
          "def": "",
          "isRequired": true,
          "type": "-"
        },
        "kernel_size": {
          "def": "Size of the max unpooling window.",
          "isRequired": true,
          "type": null
        },
        "name": {
          "def": "For detailed information, please refer to Name. Usually name is no need to set and None by default.",
          "isRequired": false,
          "type": "str"
        },
        "output_size": {
          "def": "The target output size. If output_size is not specified, the actual output shape will be automatically calculated by (input_shape, kernel_size, padding).",
          "isRequired": false,
          "type": "list|tuple"
        },
        "padding": {
          "def": "Padding that was added to the input.",
          "isRequired": false,
          "type": "int | tuple"
        },
        "stride": {
          "def": "The unpool stride size. If unpool stride size is a tuple or list, it must contain an integer.",
          "isRequired": false,
          "type": "int|list|tuple"
        }
      },
      "paddle.nn.MaxUnPool3D": {
        "data_format": {
          "def": "The data format of the input and output data. The default is \u201cNCDHW\u201d. When it is \u201cNCDHW\u201d, the data is stored in the order of: [batch_size, input_channels, input_depth, input_height, input_width].",
          "isRequired": false,
          "type": "string"
        },
        "kernel_size": {
          "def": "The unpool kernel size. If unpool kernel size is a tuple or list, it must contain an integer.",
          "isRequired": true,
          "type": "int|list|tuple"
        },
        "name": {
          "def": "For detailed information, please refer to Name. Usually name is no need to set and None by default.",
          "isRequired": false,
          "type": "str"
        },
        "output_size": {
          "def": "The target output size. If output_size is not specified, the actual output shape will be automatically calculated by (input_shape, kernel_size, stride, padding).",
          "isRequired": false,
          "type": "list|tuple"
        },
        "padding": {
          "def": "Padding that was added to the input.",
          "isRequired": false,
          "type": "int | tuple"
        },
        "stride": {
          "def": "The unpool stride size. If unpool stride size is a tuple or list, it must contain an integer.",
          "isRequired": false,
          "type": "int|list|tuple"
        }
      }
    },
    "pytorch": {
      "torch.nn.MaxUnpool1d": {
        "kernel_size": {
          "def": "Size of the max pooling window.",
          "isRequired": true,
          "type": "ints"
        },
        "padding": {
          "def": "Padding that was added to the input",
          "isRequired": false,
          "type": "ints"
        },
        "stride": {
          "def": "Stride of the max pooling window",
          "isRequired": false,
          "type": "ints"
        }
      },
      "torch.nn.MaxUnpool2d": {
        "kernel_size": {
          "def": "Size of the max pooling window.",
          "isRequired": true,
          "type": "ints"
        },
        "padding": {
          "def": "Padding that was added to the input",
          "isRequired": false,
          "type": "ints"
        },
        "stride": {
          "def": "Stride of the max pooling window",
          "isRequired": false,
          "type": "ints"
        }
      },
      "torch.nn.MaxUnpool3d": {
        "kernel_size": {
          "def": "Size of the max pooling window.",
          "isRequired": true,
          "type": "ints"
        },
        "padding": {
          "def": "Padding that was added to the input",
          "isRequired": false,
          "type": "ints"
        },
        "stride": {
          "def": "Stride of the max pooling window",
          "isRequired": false,
          "type": "ints"
        }
      }
    },
    "tensorflow": {}
  },
  "Min": {
    "mindspore": {
      "mindspore.ops.minimum": {
        "input": {
          "def": "The first input is a number or a bool or a tensor whose data type is number or bool.",
          "isRequired": true,
          "type": "Union[tensor, Number, bool]"
        },
        "other": {
          "def": "The second input is a number or a bool when the first input is a tensor or a tensor whose data type is number or bool.",
          "isRequired": true,
          "type": "Union[tensor, Number, bool]"
        }
      }
    },
    "onnx": {
      "consumed_inputs": {
        "def": "legacy optimization attribute.",
        "type": "ints"
      }
    },
    "paddlepaddle": {
      "paddle.minimum": {
        "name": {
          "def": "Name for the operation (optional, default is None). For more information, please refer to Name.",
          "isRequired": false,
          "type": "str"
        },
        "x": {
          "def": "the input tensor, it\u2019s data type should be float32, float64, int32, int64.",
          "isRequired": true,
          "type": "tensor"
        },
        "y": {
          "def": "the input tensor, it\u2019s data type should be float32, float64, int32, int64.",
          "isRequired": true,
          "type": "tensor"
        }
      }
    },
    "pytorch": {
      "torch.minimum": {
        "input": {
          "def": "the input tensor.",
          "isRequired": true,
          "type": "tensor"
        },
        "other": {
          "def": "the second input.",
          "isRequired": true,
          "type": "tensor"
        }
      }
    },
    "tensorflow": {
      "tf.minimum": {
        "name": {
          "def": "A name for the operation (optional).",
          "isRequired": false,
          "type": "string"
        },
        "x": {
          "def": "A tensor. Must be one of the following types: bfloat16, half, float32, float64, int8, uint8, int16, uint16, int32, uint32, int64, uint64.",
          "isRequired": true,
          "type": "tensor"
        },
        "y": {
          "def": "A tensor. Must have the same type as x.",
          "isRequired": true,
          "type": "tensor"
        }
      }
    }
  },
  "Mish": {
    "mindspore": {
      "mindspore.nn.Mish": {}
    },
    "onnx": {},
    "paddlepaddle": {
      "paddle.nn.Mish": {
        "name": {
          "def": "Name for the operation (optional, default is None). For more information, please refer to Name.",
          "isRequired": false,
          "type": "str"
        }
      }
    },
    "pytorch": {
      "torch.nn.Mish": {}
    },
    "tensorflow": {
      "tf.keras.activations.mish": {
        "x": {
          "def": "Input tensor.",
          "isRequired": true,
          "type": "tensor"
        }
      }
    }
  },
  "Mod": {
    "mindspore": {
      "mindspore.ops.fmod": {
        "input": {
          "def": "the dividend.",
          "isRequired": true,
          "type": "Union[tensor, Number]"
        },
        "other": {
          "def": "the divisor.",
          "isRequired": true,
          "type": "Union[tensor, Number]"
        }
      }
    },
    "onnx": {
      "fmod": {
        "def": "Whether the operator should behave like fmod (default=0 meaning itwill do integer mods); Set this to 1 to force fmod treatment",
        "type": "int"
      }
    },
    "paddlepaddle": {
      "paddle.mod": {}
    },
    "pytorch": {
      "torch.fmod": {
        "input": {
          "def": "the dividend",
          "isRequired": true,
          "type": "tensor"
        },
        "other": {
          "def": "the divisor",
          "isRequired": true,
          "type": "tensor"
        },
        "out": {
          "def": "the output tensor.",
          "isRequired": false,
          "type": "tensor"
        }
      }
    },
    "tensorflow": {
      "tf.math.floormod": {
        "name": {
          "def": "A name for the operation (optional).",
          "isRequired": false,
          "type": "string"
        },
        "x": {
          "def": "A tensor. Must be one of the following types: int8, int16, int32, int64, uint8, uint16, uint32, uint64, bfloat16, half, float32, float64.",
          "isRequired": true,
          "type": "tensor"
        },
        "y": {
          "def": "A tensor. Must have the same type as x.",
          "isRequired": true,
          "type": "tensor"
        }
      }
    }
  },
  "Mul": {
    "mindspore": {
      "mindspore.ops.mul": {
        "input": {
          "def": "The first input is a number.Number or a bool or a tensor whose data type is number or bool_.",
          "isRequired": true,
          "type": "Union[tensor, number.Number, bool]"
        },
        "other": {
          "def": "The second input, when the first input is a tensor, the second input should be a number.Number or bool value, or a tensor whose data type is number or bool. When the first input is Scalar, the second input must be a tensor whose data type is number or bool.",
          "isRequired": true,
          "type": "Union[tensor, number.Number, bool]"
        }
      }
    },
    "onnx": {
      "axis": {
        "def": "If set, defines the broadcast dimensions",
        "type": "int"
      },
      "broadcast": {
        "def": "Pass 1 to enable broadcasting",
        "type": "int"
      }
    },
    "paddlepaddle": {
      "paddle.multiply": {
        "name": {
          "def": "Name for the operation (optional, default is None). For more information, please refer to Name.",
          "isRequired": false,
          "type": "str"
        },
        "x": {
          "def": "the input tensor, its data type should be one of float32, float64, int32, int64, bool.",
          "isRequired": true,
          "type": "tensor"
        },
        "y": {
          "def": "the input tensor, its data type should be one of float32, float64, int32, int64, bool.",
          "isRequired": true,
          "type": "tensor"
        }
      }
    },
    "pytorch": {
      "torch.mul": {
        "input": {
          "def": "the input tensor.",
          "isRequired": true,
          "type": "tensor"
        },
        "other": {
          "def": "",
          "isRequired": true,
          "type": "tensor"
        }
      }
    },
    "tensorflow": {
      "tf.math.multiply": {
        "name": {
          "def": "A name for the operation (optional).",
          "isRequired": false,
          "type": "string"
        },
        "x": {
          "def": "A tensor. Must be one of the following types: bfloat16, half, float32, float64, uint8, int8, uint16, int16, int32, int64, complex64, complex128.",
          "isRequired": true,
          "type": "tensor"
        },
        "y": {
          "def": "A tensor. Must have the same type as x.",
          "isRequired": true,
          "type": "tensor"
        }
      }
    }
  },
  "Neg": {
    "mindspore": {
      "mindspore.ops.neg": {
        "input": {
          "def": "The input tensor with a dtype of Number.",
          "isRequired": true,
          "type": "tensor"
        }
      }
    },
    "onnx": {
      "consumed_inputs": {
        "def": "legacy optimization attribute.",
        "type": "ints"
      }
    },
    "paddlepaddle": {
      "paddle.neg": {
        "name": {
          "def": "Name for the operation (optional, default is None). For more information, please refer to Name.",
          "isRequired": false,
          "type": "str"
        },
        "x": {
          "def": "Input of neg operator, an N-D tensor, with data type float32, float64, int8, int16, int32, or int64.",
          "isRequired": true,
          "type": "tensor"
        }
      }
    },
    "pytorch": {},
    "tensorflow": {}
  },
  "PRelu": {
    "mindspore": {
      "mindspore.nn.PReLU": {
        "channel": {
          "def": "The elements number of parameter \\(w\\). It could be an int, and the value is 1 or the channels number of input tensor x. Default: 1 .",
          "isRequired": false,
          "type": "int"
        },
        "w": {
          "def": "The initial value of parameter. It could be a float, a float list or a tensor has the same dtype as the input tensor x. Default: 0.25 .",
          "isRequired": false,
          "type": "Union[float, list, tensor]"
        }
      }
    },
    "onnx": {
      "consumed_inputs": {
        "def": "legacy optimization attribute.",
        "type": "ints"
      }
    },
    "paddlepaddle": {
      "paddle.nn.PReLU": {
        "data_format": {
          "def": "Data format that specifies the layout of input. It may be \u201cNC\u201d, \u201cNCL\u201d, \u201cNCHW\u201d, \u201cNCDHW\u201d, \u201cNLC\u201d, \u201cNHWC\u201d or \u201cNDHWC\u201d. Default: \u201cNCHW\u201d.",
          "isRequired": false,
          "type": "str"
        },
        "init": {
          "def": "Init value of learnable weight. Default is 0.25.",
          "isRequired": false,
          "type": "float"
        },
        "name": {
          "def": "Name for the operation (optional, default is None). For more information, please refer to Name.",
          "isRequired": false,
          "type": "str"
        },
        "num_parameters": {
          "def": "Number of weight to learn. The supported values are: 1 - a single parameter alpha is used for all input channels; Number of channels - a separate alpha is used for each input channel. Default is 1.",
          "isRequired": false,
          "type": "int"
        },
        "weight_attr": {
          "def": "The parameter attribute for the learnable weight. Default is None. For more information, please refer to ParamAttr.",
          "isRequired": false,
          "type": "ParamAttr"
        }
      }
    },
    "pytorch": {
      "torch.nn.PReLU": {
        "init": {
          "def": "the initial value of aaa",
          "isRequired": false,
          "type": "float"
        },
        "num_parameters": {
          "def": "number of aaa to learn",
          "isRequired": false,
          "type": "int"
        }
      }
    },
    "tensorflow": {
      "tf.keras.layers.PReLU": {
        "alpha_constraint": {
          "def": "Constraint for the weights.",
          "isRequired": false,
          "type": "string"
        },
        "alpha_initializer": {
          "def": "Initializer function for the weights.",
          "isRequired": false,
          "type": "string"
        },
        "alpha_regularizer": {
          "def": "Regularizer for the weights.",
          "isRequired": false,
          "type": "string"
        },
        "shared_axes": {
          "def": "The axes along which to share learnable parameters for the activation function. For example, if the incoming feature maps are from a 2D convolution with output shape (batch, height, width, channels), and you wish to share parameters across space so that each filter only has one set of parameters, set shared_axes=[1, 2].",
          "isRequired": false,
          "type": "int"
        }
      }
    }
  },
  "Pow": {
    "mindspore": {
      "mindspore.ops.pow": {
        "exponent": {
          "def": "The second input, when the first input is a tensor, the second input should be a number.Number or bool value, or a tensor whose data type is number or bool_. When the first input is Scalar, the second input must be a tensor whose data type is number or bool_.",
          "isRequired": true,
          "type": "Union[tensor, number.Number, bool]"
        },
        "input": {
          "def": "The first input is a number.Number or a bool or a tensor whose data type is number or bool_.",
          "isRequired": true,
          "type": "Union[tensor, number.Number, bool]"
        }
      }
    },
    "onnx": {
      "axis": {
        "def": "If set, defines the broadcast dimensions",
        "type": "int"
      },
      "broadcast": {
        "def": "Pass 1 to enable broadcasting",
        "type": "int"
      }
    },
    "paddlepaddle": {
      "paddle.pow": {
        "name": {
          "def": "Name for the operation (optional, default is None). For more information, please refer to Name.",
          "isRequired": false,
          "type": "str"
        },
        "x": {
          "def": "An N-D tensor, the data type is float16, float32, float64, int32 or int64.",
          "isRequired": true,
          "type": "tensor"
        },
        "y": {
          "def": "If it is an N-D tensor, its data type should be the same as x.",
          "isRequired": true,
          "type": "float|int|tensor"
        }
      }
    },
    "pytorch": {
      "torch.pow": {
        "exponent": {
          "def": "the exponent tensor.",
          "isRequired": true,
          "type": "tensor"
        },
        "input": {
          "def": "the input tensor.",
          "isRequired": true,
          "type": "tensor"
        },
        "out": {
          "def": "the output tensor.",
          "isRequired": false,
          "type": "tensor"
        },
        "self": {
          "def": "the scalar base value for the power operation",
          "isRequired": false,
          "type": "float"
        }
      }
    },
    "tensorflow": {
      "tf.math.pow": {
        "name": {
          "def": "A name for the operation (optional).",
          "isRequired": false,
          "type": "string"
        },
        "x": {
          "def": "A tensor of type float16, float32, float64, int32, int64, complex64, or complex128.",
          "isRequired": true,
          "type": "tensor"
        },
        "y": {
          "def": "A tensor of type float16, float32, float64, int32, int64, complex64, or complex128.",
          "isRequired": true,
          "type": "tensor"
        }
      }
    }
  },
  "Reciprocal": {
    "mindspore": {
      "mindspore.ops.reciprocal": {
        "input": {
          "def": "The input tensor. \n where \n means, any number of additional dimensions.",
          "isRequired": true,
          "type": "tensor"
        }
      }
    },
    "onnx": {
      "consumed_inputs": {
        "def": "legacy optimization attribute.",
        "type": "ints"
      }
    },
    "paddlepaddle": {
      "paddle.reciprocal": {
        "name": {
          "def": "Name for the operation (optional, default is None). For more information, please refer to Name.",
          "isRequired": false,
          "type": "str"
        },
        "x": {
          "def": "Input of Reciprocal operator, an N-D tensor, with data type float32, float64 or float16.",
          "isRequired": true,
          "type": "tensor"
        }
      }
    },
    "pytorch": {
      "torch.reciprocal": {
        "input": {
          "def": "the input tensor.",
          "isRequired": true,
          "type": "tensor"
        }
      }
    },
    "tensorflow": {
      "tf.math.reciprocal": {
        "name": {
          "def": "A name for the operation (optional).",
          "isRequired": false,
          "type": "string"
        },
        "x": {
          "def": "A tensor. Must be one of the following types: bfloat16, half, float32, float64, int8, int16, int32, int64, complex64, complex128.",
          "isRequired": true,
          "type": "tensor"
        }
      }
    }
  },
  "ReduceMax": {
    "mindspore": {
      "mindspore.ops.max": {
        "axis": {
          "def": "The dimension to reduce. When axis is None, computing the maximum value of all elements in input .Default: None .",
          "isRequired": false,
          "type": "int"
        },
        "input": {
          "def": "The input tensor, can be any dimension. Complex tensor is not supported for now.",
          "isRequired": true,
          "type": "tensor"
        },
        "keepdims": {
          "def": "Whether to reduce dimension, if true, the output will keep same dimension with the input, the output will reduce dimension if false. Default: False .",
          "isRequired": false,
          "type": "bool"
        }
      }
    },
    "onnx": {
      "keepdims": {
        "def": "Keep the reduced dimension or not, default 1 means keep reduceddimension.",
        "type": "int"
      },
      "noop_with_empty_axes": {
        "def": "Defines behavior if \u2018axes\u2019 is empty",
        "type": "int"
      }
    },
    "paddlepaddle": {
      "paddle.max": {
        "axis": {
          "def": "The axis along which the maximum is computed. If None, compute the maximum over all elements of x and return a tensor with a single element, otherwise must be in the range \\([-x.ndim(x), x.ndim(x))\\). If \\(axis[i] < 0\\), the axis to reduce is \\(x.ndim + axis[i]\\).",
          "isRequired": false,
          "type": "int|list|tuple"
        },
        "keepdim": {
          "def": "Whether to reserve the reduced dimension in the output tensor. The result tensor will have one fewer dimension than the x unless keepdim is true, default value is False.",
          "isRequired": false,
          "type": "bool"
        },
        "name": {
          "def": "Name for the operation (optional, default is None). For more information, please refer to Name.",
          "isRequired": false,
          "type": "str"
        },
        "x": {
          "def": "A tensor, the data type is float32, float64, int32, int64.",
          "isRequired": true,
          "type": "tensor"
        }
      }
    },
    "pytorch": {
      "torch.max": {
        "input": {
          "def": "the input tensor.",
          "isRequired": true,
          "type": "tensor"
        }
      }
    },
    "tensorflow": {
      "tf.reduce_max": {
        "axis": {
          "def": "The dimensions to reduce. If None (the default), reduces all dimensions. Must be in the range [-rank(input_tensor), rank(input_tensor)).",
          "isRequired": false,
          "type": "int"
        },
        "input_tensor": {
          "def": "The tensor to reduce. Should have real numeric type.",
          "isRequired": true,
          "type": "tensor"
        },
        "keepdims": {
          "def": "If true, retains reduced dimensions with length 1.",
          "isRequired": false,
          "type": "bool"
        },
        "name": {
          "def": "A name for the operation (optional).",
          "isRequired": false,
          "type": "string"
        }
      }
    }
  },
  "ReduceMean": {
    "mindspore": {
      "mindspore.ops.mean": {
        "axis": {
          "def": "The dimensions to reduce. Default: None , reduce all dimensions. Only constant value is allowed. Assume the rank of x is r, and the value range is [-r,r).",
          "isRequired": false,
          "type": "Union[int, tuple(int"
        },
        "keep_dims": {
          "def": "If true, keep these reduced dimensions and the length is 1. If false, don\u2019t keep these dimensions. Default: False .",
          "isRequired": false,
          "type": "bool"
        },
        "x": {
          "def": "The input tensor. The dtype of the tensor to be reduced is number. \\((N, *)\\) where \\(*\\) means, any number of additional dimensions.",
          "isRequired": true,
          "type": "tensor[Number]"
        }
      }
    },
    "onnx": {
      "keepdims": {
        "def": "Keep the reduced dimension or not, default 1 means keep reduceddimension.",
        "type": "int"
      },
      "noop_with_empty_axes": {
        "def": "Defines behavior if \u2018axes\u2019 is empty",
        "type": "int"
      }
    },
    "paddlepaddle": {
      "paddle.mean": {
        "axis": {
          "def": "The axis along which to perform mean calculations. axis should be int, list(int) or tuple(int). If axis is a list/tuple of dimension(s), mean is calculated along all element(s) of axis . axis or element(s) of axis should be in range [-D, D), where D is the dimensions of x . If axis or element(s) of axis is less than 0, it works the same way as \\(axis + D\\) . If axis is None, mean is calculated over all elements of x. Default is None.",
          "isRequired": false,
          "type": "int|list|tuple"
        },
        "keepdim": {
          "def": "Whether to reserve the reduced dimension(s) in the output tensor. If keepdim is True, the dimensions of the output tensor is the same as x except in the reduced dimensions(it is of size 1 in this case). Otherwise, the shape of the output tensor is squeezed in axis . Default is False.",
          "isRequired": false,
          "type": "bool"
        },
        "name": {
          "def": "Name for the operation (optional, default is None). For more information, please refer to Name.",
          "isRequired": false,
          "type": "str"
        },
        "x": {
          "def": "The input tensor with data type float32, float64.",
          "isRequired": true,
          "type": "tensor"
        }
      }
    },
    "pytorch": {
      "torch.mean": {
        "dtype": {
          "def": "the desired data type of returned tensor",
          "isRequired": false,
          "type": "torchdtype"
        },
        "input": {
          "def": "the input tensor.",
          "isRequired": true,
          "type": "tensor"
        }
      }
    },
    "tensorflow": {
      "tf.reduce_mean": {
        "axis": {
          "def": "The dimensions to reduce. If None (the default), reduces all dimensions. Must be in the range [-rank(input_tensor), rank(input_tensor)).",
          "isRequired": false,
          "type": "int"
        },
        "input_tensor": {
          "def": "The tensor to reduce. Should have numeric type.",
          "isRequired": true,
          "type": "tensor"
        },
        "keepdims": {
          "def": "If true, retains reduced dimensions with length 1.",
          "isRequired": false,
          "type": "bool"
        },
        "name": {
          "def": "A name for the operation (optional).",
          "isRequired": false,
          "type": "string"
        }
      }
    }
  },
  "ReduceMin": {
    "mindspore": {
      "mindspore.ops.min": {
        "axis": {
          "def": "The dimension to reduce. Default: None .",
          "isRequired": false,
          "type": "int"
        },
        "input": {
          "def": "The input tensor, can be any dimension. Complex tensor is not supported for now.",
          "isRequired": true,
          "type": "tensor"
        },
        "keepdims": {
          "def": "Whether to reduce dimension, if True the output will keep the same dimension as the input, the output will reduce dimension if False . Default: False .",
          "isRequired": false,
          "type": "bool"
        }
      }
    },
    "onnx": {
      "keepdims": {
        "def": "Keep the reduced dimension or not, default 1 means keep reduceddimension.",
        "type": "int"
      },
      "noop_with_empty_axes": {
        "def": "Defines behavior if \u2018axes\u2019 is empty",
        "type": "int"
      }
    },
    "paddlepaddle": {
      "paddle.min": {
        "axis": {
          "def": "The axis along which the minimum is computed. If None, compute the minimum over all elements of x and return a tensor with a single element, otherwise must be in the range \\([-x.ndim, x.ndim)\\). If \\(axis[i] < 0\\), the axis to reduce is \\(x.ndim + axis[i]\\).",
          "isRequired": false,
          "type": "int|list|tuple"
        },
        "keepdim": {
          "def": "Whether to reserve the reduced dimension in the output tensor. The result tensor will have one fewer dimension than the x unless keepdim is true, default value is False.",
          "isRequired": false,
          "type": "bool"
        },
        "name": {
          "def": "Name for the operation (optional, default is None). For more information, please refer to Name.",
          "isRequired": false,
          "type": "str"
        },
        "x": {
          "def": "A tensor, the data type is float32, float64, int32, int64.",
          "isRequired": true,
          "type": "tensor"
        }
      }
    },
    "pytorch": {
      "torch.min": {
        "input": {
          "def": "the input tensor.",
          "isRequired": true,
          "type": "tensor"
        }
      }
    },
    "tensorflow": {
      "tf.reduce_min": {
        "axis": {
          "def": "The dimensions to reduce. If None (the default), reduces all dimensions. Must be in the range [-rank(input_tensor), rank(input_tensor)).",
          "isRequired": false,
          "type": "int"
        },
        "input_tensor": {
          "def": "The tensor to reduce. Should have real numeric type.",
          "isRequired": true,
          "type": "tensor"
        },
        "keepdims": {
          "def": "If true, retains reduced dimensions with length 1.",
          "isRequired": false,
          "type": "bool"
        },
        "name": {
          "def": "A name for the operation (optional).",
          "isRequired": false,
          "type": "string"
        }
      }
    }
  },
  "ReduceProd": {
    "mindspore": {
      "mindspore.ops.prod": {
        "axis": {
          "def": "The dimensions to reduce. Default: None , reduce all dimensions. Only constant value is allowed. Assume the rank of input is r, and the value range is [-r,r).",
          "isRequired": false,
          "type": "Union[int, tuple(int"
        },
        "input": {
          "def": "The input tensor. The dtype of the tensor to be reduced is number. \\((N, *)\\) where \\(*\\) means, any number of additional dimensions.",
          "isRequired": true,
          "type": "tensor[Number]"
        },
        "keep_dims": {
          "def": "If true, keep these reduced dimensions and the length is 1. If false, don\u2019t keep these dimensions. Default: False .",
          "isRequired": false,
          "type": "bool"
        }
      }
    },
    "onnx": {
      "keepdims": {
        "def": "Keep the reduced dimension or not, default 1 means keep reduceddimension.",
        "type": "int"
      },
      "noop_with_empty_axes": {
        "def": "Defines behavior if \u2018axes\u2019 is empty",
        "type": "int"
      }
    },
    "paddlepaddle": {
      "paddle.prod": {
        "axis": {
          "def": "The axis along which the product is computed. If None, multiply all elements of x and return a tensor with a single element, otherwise must be in the range \\([-x.ndim, x.ndim)\\). If \\(axis[i]<0\\), the axis to reduce is \\(x.ndim + axis[i]\\). Default is None.",
          "isRequired": false,
          "type": "int|list|tuple"
        },
        "dtype": {
          "def": "The desired date type of returned tensor, can be float32, float64, int32, int64. If specified, the input tensor is casted to dtype before operator performed. This is very useful for avoiding data type overflows. The default value is None, the dtype of output is the same as input tensor x.",
          "isRequired": false,
          "type": "str|np.dtype"
        },
        "keepdim": {
          "def": "Whether to reserve the reduced dimension in the output tensor. The result tensor will have one fewer dimension than the input unless keepdim is true. Default is False.",
          "isRequired": false,
          "type": "bool"
        },
        "name": {
          "def": "Name for the operation (optional, default is None). For more information, please refer to Name.",
          "isRequired": false,
          "type": "str"
        },
        "x": {
          "def": "The input tensor, its data type should be float32, float64, int32, int64.",
          "isRequired": true,
          "type": "tensor"
        }
      }
    },
    "pytorch": {
      "torch.prod": {
        "dtype": {
          "def": "the desired data type of returned tensor",
          "isRequired": false,
          "type": "torchdtype"
        },
        "input": {
          "def": "the input tensor.",
          "isRequired": true,
          "type": "tensor"
        }
      }
    },
    "tensorflow": {
      "tf.reduce_prod": {
        "axis": {
          "def": "The dimensions to reduce. If None (the default), reduces all dimensions. Must be in the range [-rank(input_tensor), rank(input_tensor)).",
          "isRequired": false,
          "type": "int"
        },
        "input_tensor": {
          "def": "The tensor to reduce. Should have numeric type.",
          "isRequired": true,
          "type": "tensor"
        },
        "keepdims": {
          "def": "If true, retains reduced dimensions with length 1.",
          "isRequired": false,
          "type": "bool"
        },
        "name": {
          "def": "A name for the operation (optional).",
          "isRequired": false,
          "type": "string"
        }
      }
    }
  },
  "ReduceSum": {
    "mindspore": {
      "mindspore.ops.sum": {
        "dim": {
          "def": "Dimensions along which a sum is performed. If None, sum all the elements of the input tensor. If the dim is a tuple or list of ints, a sum is performed on all the dimensions specified in the tuple. Must be in the range \\([-input.ndim, input.ndim)\\) . Default: None.",
          "isRequired": false,
          "type": "Union[None, int, tuple(int"
        },
        "input": {
          "def": "The input tensor.",
          "isRequired": true,
          "type": "tensor"
        },
        "keepdim": {
          "def": "Whether the output tensor has dim retained or not. If True, keep these reduced dimensions and the length is 1. If False, don\u2019t keep these dimensions. Default: False.",
          "isRequired": false,
          "type": "bool"
        }
      }
    },
    "onnx": {
      "keepdims": {
        "def": "Keep the reduced dimension or not, default 1 means keep reduceddimension.",
        "type": "int"
      },
      "noop_with_empty_axes": {
        "def": "Defines behavior if \u2018axes\u2019 is empty",
        "type": "int"
      }
    },
    "paddlepaddle": {
      "paddle.sum": {
        "axis": {
          "def": "The dimensions along which the sum is performed. If None, sum all elements of x and return a tensor with a single element, otherwise must be in the range \\([-rank(x), rank(x))\\). If \\(axis[i] < 0\\), the dimension to reduce is \\(rank + axis[i]\\).",
          "isRequired": false,
          "type": "int|list|tuple"
        },
        "dtype": {
          "def": "The dtype of output tensor. The default value is None, the dtype of output is the same as input tensor x.",
          "isRequired": false,
          "type": "str"
        },
        "keepdim": {
          "def": "Whether to reserve the reduced dimension in the output tensor. The result tensor will have one fewer dimension than the x unless keepdim is true, default value is False.",
          "isRequired": false,
          "type": "bool"
        },
        "name": {
          "def": "Name for the operation (optional, default is None). For more information, please refer to Name.",
          "isRequired": false,
          "type": "str"
        },
        "x": {
          "def": "An N-D tensor, the data type is bool, float16, float32, float64, int32 or int64.",
          "isRequired": true,
          "type": "tensor"
        }
      }
    },
    "pytorch": {
      "torch.sum": {
        "dtype": {
          "def": "the desired data type of returned tensor",
          "isRequired": false,
          "type": "torchdtype"
        },
        "input": {
          "def": "the input tensor.",
          "isRequired": true,
          "type": "tensor"
        }
      }
    },
    "tensorflow": {
      "tf.reduce_sum": {
        "axis": {
          "def": "The dimensions to reduce. If None (the default), reduces all dimensions. Must be in the range [-rank(input_tensor), rank(input_tensor)].",
          "isRequired": false,
          "type": "int"
        },
        "input_tensor": {
          "def": "The tensor to reduce. Should have numeric type.",
          "isRequired": true,
          "type": "tensor"
        },
        "keepdims": {
          "def": "If true, retains reduced dimensions with length 1.",
          "isRequired": false,
          "type": "bool"
        },
        "name": {
          "def": "A name for the operation (optional).",
          "isRequired": false,
          "type": "string"
        }
      }
    }
  },
  "Relu": {
    "mindspore": {
      "mindspore.nn.ReLU": {
        "x": {
          "def": "x (tensor) - The input of ReLU is a tensor of any dimension. The data type is number .",
          "isRequired": true,
          "type": "tensor"
        }
      }
    },
    "onnx": {
      "consumed_inputs": {
        "def": "legacy optimization attribute.",
        "type": "ints"
      }
    },
    "paddlepaddle": {
      "paddle.nn.ReLU": {
        "name": {
          "def": "Name for the operation (optional, default is None). For more information, please refer to Name.",
          "isRequired": false,
          "type": "str"
        }
      }
    },
    "pytorch": {
      "torch.nn.ReLU": {
        "inplace": {
          "def": "can optionally do the operation in-place",
          "isRequired": false,
          "type": "bool"
        }
      },
      "torch.nn.functional.relu": {
        "inplace": {
          "def": "can optionally do the operation in-place",
          "isRequired": false,
          "type": "bool"
        },
        "input": {
          "def": "the input tensor.",
          "isRequired": true,
          "type": "tensor"
        }
      }
    },
    "tensorflow": {
      "tf.keras.activations.relu": {
        "alpha": {
          "def": "A float that governs the slope for values lower than the threshold.",
          "isRequired": false,
          "type": "float"
        },
        "max_value": {
          "def": "A float that sets the saturation threshold (the largest value the function will return).",
          "isRequired": false,
          "type": "float"
        },
        "threshold": {
          "def": "A float giving the threshold value of the activation function below which values will be damped or set to zero.",
          "isRequired": false,
          "type": "float"
        },
        "x": {
          "def": "Input tensor or variable.",
          "isRequired": true,
          "type": "tensor"
        }
      },
      "tf.keras.layers.ReLU": {
        "max_value": {
          "def": "Float >= 0. Maximum activation value. None means unlimited. Defaults to None.",
          "isRequired": false,
          "type": "float"
        },
        "negative_slope": {
          "def": "Float >= 0. Negative slope coefficient. Defaults to 0..",
          "isRequired": false,
          "type": "float"
        },
        "threshold": {
          "def": "Float >= 0. Threshold value for thresholded activation. Defaults to 0..",
          "isRequired": false,
          "type": "float"
        }
      },
      "tf.nn.relu": {
        "features": {
          "def": "A tensor. Must be one of the following types: float32, float64, int32, uint8, int16, int8, int64, bfloat16, uint16, half, uint32, uint64, qint8.",
          "isRequired": true,
          "type": "tensor"
        },
        "name": {
          "def": "A name for the operation (optional).",
          "isRequired": false,
          "type": "string"
        }
      }
    }
  },
  "Reshape": {
    "mindspore": {},
    "onnx": {
      "allowzero": {
        "def": "(Optional) By default, when any value in the \u2018shape\u2019 input is equalto zero the corresponding dimension value is copied from the inputtensor dynamically",
        "type": "int"
      }
    },
    "paddlepaddle": {},
    "pytorch": {
      "torch.reshape": {
        "input": {
          "def": "the tensor to be reshaped",
          "isRequired": true,
          "type": "tensor"
        },
        "shape": {
          "def": "the new shape",
          "isRequired": true,
          "type": "ints"
        }
      }
    },
    "tensorflow": {
      "tf.keras.layers.Reshape": {
        "target_shape": {
          "def": "Target shape. Tuple of integers, does not include the samples dimension (batch size).",
          "isRequired": true,
          "type": "ints"
        }
      }
    }
  },
  "Round": {
    "mindspore": {
      "mindspore.ops.round": {
        "input": {
          "def": "The input tensor.",
          "isRequired": true,
          "type": "tensor"
        }
      }
    },
    "onnx": {},
    "paddlepaddle": {
      "paddle.round": {
        "name": {
          "def": "Name for the operation (optional, default is None). For more information, please refer to Name.",
          "isRequired": false,
          "type": "str"
        },
        "x": {
          "def": "Input of Round operator, an N-D tensor, with data type float32, float64 or float16.",
          "isRequired": true,
          "type": "tensor"
        }
      }
    },
    "pytorch": {
      "torch.round": {
        "decimals": {
          "def": "Number of decimal places to round to (default: 0)",
          "isRequired": false,
          "type": "int"
        },
        "input": {
          "def": "the input tensor.",
          "isRequired": true,
          "type": "tensor"
        },
        "out": {
          "def": "the output tensor.",
          "isRequired": false,
          "type": "tensor"
        }
      }
    },
    "tensorflow": {
      "tf.math.round": {
        "name": {
          "def": "A name for the operation (optional).",
          "isRequired": false,
          "type": "string"
        },
        "x": {
          "def": "A tensor of type float16, float32, float64, int32, or int64.",
          "isRequired": true,
          "type": "tensor"
        }
      }
    }
  },
  "Selu": {
    "mindspore": {
      "mindspore.nn.SeLU": {}
    },
    "onnx": {
      "alpha": {
        "def": "Coefficient of SELU default to 1.67326319217681884765625 (i.e.,float32 approximation of 1.6732632423543772848170429916717).",
        "type": "float"
      },
      "gamma": {
        "def": "Coefficient of SELU default to 1.05070102214813232421875 (i.e.,float32 approximation of 1.0507009873554804934193349852946).",
        "type": "float"
      }
    },
    "paddlepaddle": {
      "paddle.nn.SELU": {
        "alpha": {
          "def": "The value of alpha(must be no less than zero) for SELU. Default is 1.6732632423543772848170429916717.",
          "isRequired": false,
          "type": "float"
        },
        "name": {
          "def": "Name for the operation (optional, default is None). For more information, please refer to Name.",
          "isRequired": false,
          "type": "str"
        },
        "scale": {
          "def": "The value of scale(must be greater than 1.0) for SELU. Default is 1.0507009873554804934193349852946.",
          "isRequired": false,
          "type": "float"
        }
      }
    },
    "pytorch": {
      "torch.nn.SELU": {
        "inplace": {
          "def": "can optionally do the operation in-place",
          "isRequired": false,
          "type": "bool"
        }
      }
    },
    "tensorflow": {
      "tf.keras.activations.selu": {
        "x": {
          "def": "A tensor or variable to compute the activation function for.",
          "isRequired": true,
          "type": "tensor"
        }
      },
      "tf.nn.selu": {
        "features": {
          "def": "A tensor. Must be one of the following types: half, bfloat16, float32, float64.",
          "isRequired": true,
          "type": "tensor"
        },
        "name": {
          "def": "A name for the operation (optional).",
          "isRequired": false,
          "type": "string"
        }
      }
    }
  },
  "Sigmoid": {
    "mindspore": {
      "mindspore.nn.Sigmoid": {
        "input_x": {
          "def": "input_x (tensor) - tensor of any dimension, the data type is float16, float32, float64, complex64 or complex128.",
          "isRequired": true,
          "type": "tensor"
        }
      }
    },
    "onnx": {
      "consumed_inputs": {
        "def": "legacy optimization attribute.",
        "type": "ints"
      }
    },
    "paddlepaddle": {
      "paddle.nn.Sigmoid": {
        "name": {
          "def": "For details, please refer to Name. Generally, no setting is required. Default: None.",
          "isRequired": false,
          "type": "str"
        }
      }
    },
    "pytorch": {
      "torch.nn.Sigmoid": {}
    },
    "tensorflow": {
      "tf.keras.activations.sigmoid": {
        "x": {
          "def": "Input tensor.",
          "isRequired": true,
          "type": "tensor"
        }
      },
      "tf.math.sigmoid": {
        "name": {
          "def": "A name for the operation (optional).",
          "isRequired": false,
          "type": "string"
        },
        "x": {
          "def": "A tensor with type float16, float32, float64, complex64, or complex128.",
          "isRequired": true,
          "type": "tensor"
        }
      }
    }
  },
  "Softmax": {
    "mindspore": {
      "mindspore.nn.Softmax": {
        "axis": {
          "def": "The axis to apply Softmax operation, if the dimension of input x is x.ndim, the range of axis is [-x.ndim, x.ndim), -1 means the last dimension. Default: -1 .",
          "isRequired": false,
          "type": "int"
        }
      },
      "mindspore.nn.Softmax2d": {
        "x": {
          "def": "x (tensor) - tensor of shape \\((N, C_{in}, H_{in}, W_{in})\\) or \\((C_{in}, H_{in}, W_{in})\\). The input of Softmax with data type of float16 or float32.",
          "isRequired": true,
          "type": "tensor"
        }
      }
    },
    "onnx": {
      "axis": {
        "def": " Describes the dimension Softmax will be performed on",
        "type": "int"
      }
    },
    "paddlepaddle": {
      "paddle.nn.Softmax": {
        "axis": {
          "def": "The axis along which to perform log_softmax calculations. It should be in range [-D, D), where D is the dimensions of x . If axis < 0, it works the same way as \\(axis + D\\) . Default is -1.",
          "isRequired": false,
          "type": "int"
        },
        "name": {
          "def": "Name for the operation (optional, default is None). For more information, please refer to Name.",
          "isRequired": false,
          "type": "str"
        }
      },
      "paddle.nn.Softmax2D": {
        "**kwargs": {
          "def": "unpacked dict arguments",
          "isRequired": true,
          "type": "dict"
        },
        "*inputs": {
          "def": "unpacked tuple arguments",
          "isRequired": true,
          "type": "tuple"
        }
      }
    },
    "pytorch": {
      "torch.nn.Softmax": {
        "dim": {
          "def": "A dimension along which Softmax will be computed (so every slice along dim will sum to 1).",
          "isRequired": false,
          "type": "int"
        }
      },
      "torch.nn.Softmax2d": {}
    },
    "tensorflow": {
      "tf.keras.activations.softmax": {
        "axis": {
          "def": "Integer, axis along which the softmax normalization is applied.",
          "isRequired": false,
          "type": "int"
        },
        "x": {
          "def": "Input tensor.",
          "isRequired": true,
          "type": "tensor"
        }
      },
      "tf.keras.layers.Softmax": {
        "axis": {
          "def": "Integer, or list of Integers, axis along which the softmax normalization is applied.",
          "isRequired": false,
          "type": "int"
        }
      },
      "tf.nn.softmax": {
        "axis": {
          "def": "The dimension softmax would be performed on. The default is -1 which indicates the last dimension.",
          "isRequired": false,
          "type": "int"
        },
        "logits": {
          "def": "A non-empty tensor. Must be one of the following types: half, float32, float64.",
          "isRequired": true,
          "type": "tensor"
        },
        "name": {
          "def": "A name for the operation (optional).",
          "isRequired": false,
          "type": "string"
        }
      }
    }
  },
  "Softplus": {
    "mindspore": {},
    "onnx": {},
    "paddlepaddle": {
      "paddle.nn.Softplus": {
        "beta": {
          "def": "The value of \\(\\beta\\) for Softplus. Default is 1",
          "isRequired": false,
          "type": "float"
        },
        "name": {
          "def": "For details, please refer to Name. Generally, no setting is required. Default: None.",
          "isRequired": false,
          "type": "str"
        },
        "threshold": {
          "def": "The value of \\(\\varepsilon\\) for Softplus. Default is 20",
          "isRequired": false,
          "type": "float"
        }
      }
    },
    "pytorch": {
      "torch.nn.Softplus": {
        "beta": {
          "def": "the \u03b2\\beta\u03b2 value for the Softplus formulation",
          "isRequired": false,
          "type": "int"
        },
        "threshold": {
          "def": "values above this revert to a linear function",
          "isRequired": false,
          "type": "int"
        }
      }
    },
    "tensorflow": {
      "tf.keras.activations.softplus": {
        "x": {
          "def": "Input tensor.",
          "isRequired": true,
          "type": "tensor"
        }
      },
      "tf.math.softplus": {
        "features": {
          "def": "tensor",
          "isRequired": true,
          "type": "tensor"
        },
        "name": {
          "def": "Optional: name to associate with this operation.",
          "isRequired": false,
          "type": "string"
        }
      }
    }
  },
  "Softsign": {
    "mindspore": {
      "mindspore.nn.Softsign": {}
    },
    "onnx": {},
    "paddlepaddle": {
      "paddle.nn.Softsign": {
        "name": {
          "def": "Name for the operation (optional, default is None). For more information, please refer to Name.",
          "isRequired": false,
          "type": "str"
        }
      }
    },
    "pytorch": {
      "torch.nn.Softsign": {}
    },
    "tensorflow": {
      "tf.keras.activations.softsign": {
        "x": {
          "def": "Input tensor.",
          "isRequired": true,
          "type": "tensor"
        }
      },
      "tf.nn.softsign": {
        "features": {
          "def": "A tensor. Must be one of the following types: half, bfloat16, float32, float64.",
          "isRequired": true,
          "type": "tensor"
        },
        "name": {
          "def": "A name for the operation (optional).",
          "isRequired": false,
          "type": "string"
        }
      }
    }
  },
  "Sub": {
    "mindspore": {
      "mindspore.ops.subtract": {
        "input": {
          "def": "tensor or Number involved in subtraction.",
          "isRequired": true,
          "type": "Union[tensor, number.Number]"
        },
        "other": {
          "def": "tensor or Number involved in subtraction.",
          "isRequired": true,
          "type": "Union[tensor, number.Number]"
        }
      }
    },
    "onnx": {
      "axis": {
        "def": "If set, defines the broadcast dimensions",
        "type": "int"
      },
      "broadcast": {
        "def": "Pass 1 to enable broadcasting",
        "type": "int"
      }
    },
    "paddlepaddle": {
      "paddle.subtract": {
        "name": {
          "def": "Name for the operation (optional, default is None). For more information, please refer to Name.",
          "isRequired": false,
          "type": "str"
        },
        "x": {
          "def": "the input tensor, it\u2019s data type should be float32, float64, int32, int64.",
          "isRequired": true,
          "type": "tensor"
        },
        "y": {
          "def": "the input tensor, it\u2019s data type should be float32, float64, int32, int64.",
          "isRequired": true,
          "type": "tensor"
        }
      }
    },
    "pytorch": {
      "torch.sub": {
        "input": {
          "def": "the input tensor.",
          "isRequired": true,
          "type": "tensor"
        },
        "other": {
          "def": "the tensor or number to subtract from input.",
          "isRequired": true,
          "type": "tensor"
        }
      }
    },
    "tensorflow": {
      "tf.math.subtract": {
        "name": {
          "def": "A name for the operation (optional).",
          "isRequired": false,
          "type": "string"
        },
        "x": {
          "def": "A tensor. Must be one of the following types: bfloat16, half, float32, float64, uint8, int8, uint16, int16, int32, int64, complex64, complex128, uint32, uint64.",
          "isRequired": true,
          "type": "tensor"
        },
        "y": {
          "def": "A tensor. Must have the same type as x.",
          "isRequired": true,
          "type": "tensor"
        }
      }
    }
  },
  "Tanh": {
    "mindspore": {
      "mindspore.nn.Tanh": {
        "x": {
          "def": "x (tensor) - tensor of any dimension, input with data type of float16 or float32.",
          "isRequired": true,
          "type": "tensor"
        }
      }
    },
    "onnx": {
      "consumed_inputs": {
        "def": "legacy optimization attribute.",
        "type": "ints"
      }
    },
    "paddlepaddle": {
      "paddle.nn.Tanh": {
        "name": {
          "def": "Name for the operation (optional, default is None). For more information, please refer to Name.",
          "isRequired": false,
          "type": "str"
        }
      }
    },
    "pytorch": {
      "torch.nn.Tanh": {}
    },
    "tensorflow": {
      "tf.keras.activations.tanh": {
        "x": {
          "def": "Input tensor.",
          "isRequired": true,
          "type": "tensor"
        }
      },
      "tf.math.tanh": {
        "name": {
          "def": "A name for the operation (optional).",
          "isRequired": false,
          "type": "string"
        },
        "x": {
          "def": "A tensor. Must be one of the following types: bfloat16, half, float32, float64, complex64, complex128.",
          "isRequired": true,
          "type": "tensor"
        }
      }
    }
  },
  "ThresholdedRelu": {
    "mindspore": {},
    "onnx": {
      "alpha": {
        "def": "Threshold value",
        "type": "float"
      }
    },
    "paddlepaddle": {
      "paddle.nn.ThresholdedReLU": {
        "name": {
          "def": "Name for the operation (optional, default is None). For more information, please refer to Name.",
          "isRequired": false,
          "type": "str"
        },
        "threshold": {
          "def": "The value of threshold for ThresholdedReLU. Default is 1.0",
          "isRequired": false,
          "type": "float"
        }
      }
    },
    "pytorch": {},
    "tensorflow": {
      "tf.keras.layers.ThresholdedReLU": {
        "theta": {
          "def": "Float >= 0. Threshold location of activation.",
          "isRequired": false,
          "type": "float"
        }
      }
    }
  },
  "Upsample": {
    "mindspore": {
      "mindspore.nn.Upsample": {
        "size": {
          "def": "The target size. If size is a tuple or list, its length should be the same as the number of dimensions in input after removing the first two dimensions N, C. One and only one of size and scale_factor can be set to None. Default: None .",
          "isRequired": false,
          "type": "int"
        },
        "scale_factor": {
          "def": "The scale factor of new size of the tensor. If scale_factor is a tuple or list, its length should be the same as the number of dimensions in input after removing the first two dimensions N, C. One and only one of size and scale_factor can be set to None. Default: None .",
          "isRequired": false,
          "type": "float"
        },
        "mode": {
          "def": "The sampling algorithm. One of ‘nearest’, ‘linear’ (3D only), ‘bilinear’ (4D only), ‘trilinear’ (5D only), ‘bicubic’ (4D only), ‘area’, ‘nearest-exact’(matches Scikit-Image and PIL nearest neighbours interpolation algorithms and fixes knows issues with nearest, 3D and 4D). Default: \"nearest\" .",
          "isRequired": false,
          "type": "str"
        },
        "align_corners": {
          "def": "If True, rescale input by \n, which exactly aligns the corners of data and resized data. If False, rescale by \n. Default: None .",
          "isRequired": false,
          "type": "bool"
        },
        "recompute_scale_factor": {
          "def": "Recalculate scale_factor. If True, the parameter size will be calculated using the value of the scale_factor, and finally scaled using the value of size. If False, the value of size or scale_factor will be used for direct interpolation. Default: None .",
          "isRequired": false,
          "type": "bool"
        }
      }
    },
    "onnx": {
      "mode": {
        "def": "Two interpolation modes: nearest (default), and linear (including bilinear, trilinear, etc)",
        "type": "string"
      }
    },
    "paddlepaddle": {
      "paddle.nn.Upsample": {
        "align_corners": {
          "def": "An optional bool, If True, the centers of the 4 corner pixels of the input and output tensors are aligned, preserving the values at the corner pixels. Default: False",
          "isRequired": false,
          "type": "bool"
        },
        "align_mode": {
          "def": "An optional for linear/bilinear/trilinear interpolation. Refer to the formula in the example above, it can be \u20180\u2019 for src_idx = scale_factor*(dst_indx+0.5)-0.5 , can be \u20181\u2019 for src_idx = scale_factor*dst_index.",
          "isRequired": false,
          "type": "int"
        },
        "data_format": {
          "def": "Specify the data format of the input, and the data format of the output will be consistent with that of the input. An optional string from:NCW, NWC, \u201cNCHW\u201d, \u201cNHWC\u201d, \u201cNCDHW\u201d, \u201cNDHWC\u201d. The default is \u201cNCHW\u201d. When it is \u201cNCHW\u201d, the data is stored in the order of: [batch_size, input_channels, input_height, input_width]. When it is \u201cNCHW\u201d, the data is stored in the order of: [batch_size, input_channels, input_depth, input_height, input_width].",
          "isRequired": false,
          "type": "str"
        },
        "mode": {
          "def": "The resample method. It supports \u2018linear\u2019, \u2018nearst\u2019, \u2018bilinear\u2019, \u2018bicubic\u2019 and \u2018trilinear\u2019 currently. Default: \u2018nearest\u2019",
          "isRequired": false,
          "type": "str"
        },
        "name": {
          "def": "The default value is None. Normally there is no need for user to set this property. For more information, please refer to Name",
          "isRequired": false,
          "type": "str"
        },
        "scale_factor": {
          "def": "The multiplier for the input height or width. At least one of size or scale_factor must be set. And size has a higher priority than scale_factor. Has to match input size if it is either a list or a tuple or a tensor. Default: None.",
          "isRequired": false,
          "type": "float|tensor|list|tuple|None"
        },
        "size": {
          "def": "Output shape of image resize layer, the shape is (out_w, ) when input is a 3-D tensor, the shape is (out_h, out_w) when input is a 4-D tensor and is (out_d, out_h, out_w) when input is a 5-D tensor. Default: None. If a list/tuple, each element can be an integer or a tensor of shape: [1]. If a tensor , its dimensions size should be a 1.",
          "isRequired": false,
          "type": "list|tuple|tensor|None"
        },
        "x": {
          "def": "3-D, 4-D or 5-D tensor, its data type is float32, float64, or uint8, its data format is specified by data_format.",
          "isRequired": true,
          "type": "tensor"
        }
      }
    },
    "pytorch": {
      "torch.nn.Upsample": {
        "align_corners": {
          "def": "if True, the corner pixels of the input and output tensors are aligned, and thus preserving the values at those pixels",
          "isRequired": false,
          "type": "bool"
        },
        "mode": {
          "def": "the upsampling algorithm: one of 'nearest', 'linear', 'bilinear', 'bicubic' and 'trilinear'",
          "isRequired": false,
          "type": "string"
        },
        "recompute_scale_factor": {
          "def": "recompute the scale_factor for use in the interpolation calculation",
          "isRequired": false,
          "type": "bool"
        },
        "scale_factor": {
          "def": "multiplier for spatial size",
          "isRequired": false,
          "type": "float or tuplefloat or tuplefloat float or tuplefloat float float"
        },
        "size": {
          "def": "output spatial sizes",
          "isRequired": false,
          "type": "int or tupleint or tupleint int or tupleint int int"
        }
      }
    },
    "tensorflow": {}
  }
}